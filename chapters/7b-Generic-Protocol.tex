% !TEX root = ..\Main.tex
\chapter{Generic ILC Protocols}
\label{chapterlabel:Generic-Protocol}

In this section, we present efficient \ILC\ protocols for a variety of different statements.

\section{Remarks} Before stating our \ILC \ protocols, we briefly discuss how \ILC\ proofs will be compiled into real proofs. This will motivate the efficiency discussions after each protocol. In the \ILC \ protocols, the prover will commit to vectors by sending them to \ILC. After interacting with the prover, the verifier will make several \ILC\ queries in order to obtain certain linear combinations of the committed vectors. In real, compiled protocols, the prover will commit to vectors using the commitment scheme, and will personally compute and send the linear combinations requested by the verifier. Therefore, when discussing the communication costs of \ILC \ protocols, we will refer to the number and length of committed vectors, and the number and length of vectors which form the verifier's queries to the \ILC. When discussing the computational costs of the protocols, we will refer to the number and length of committed vectors, and the cost in field multiplications for the prover, verifier, and \ILC.

As discussed earlier, when the verifier makes a \ILCcheck\ query, the result will not be counted as part of the communication complexity of the protocol. This is because in the original compilation from \ILC\ protocols to standard zero-knowledge protocols given in \cite{BootleCGGHJ17}, all \ILCopen\ queries made by the verifier end up being computed and sent by the prover in the compiled protocol. Then, the verifier checks all query answers against commitments, and checks that the query answers satisfy certain equations. For example, the verifier might query \ILC\ and obtain vectors $\bar{\vec{a}}$, $\bar{\vec{b}}$ and $\bar{\vec{c}}$. Then, in the real proof, the verifier would check $\bar{\vec{a}}$, $\bar{\vec{b}}$ and $\bar{\vec{c}}$ against committed values, and check some equations, such as $\bar{\vec{a}} \circ \bar{\vec{b}} = \bar{\vec{c}}$, for example. However, rather than actually make a query for $\bar{\vec{c}}$, the verifier could simply check $\bar{\vec{a}} \circ \bar{\vec{b}}$ against the commitments for $\bar{\vec{c}}$. Since the verifier can compute for themselves what $\bar{\vec{c}}$ ought to be from the verification equations, there is no need for the verifier to receive this values. The \ILCcheck\ command is used to distinguish this case, which should not be counted as part of the communication costs of a proof. Furthermore, linear combinations queried using \ILCcheck\ queries do not need to be generated by the simulator, as they can already be computed using the answers to other \ILCopen\ queries.

Throughout this chapter, we will present \ILC \ protocols over a field $|\F|$ and prove that they have soundness error $poly(\sep) / |\F|$. We will assume that $|\F|$ is sufficiently large so that the protocols have negligible soundness error. However, if this is not the case, then in Section \ref{sec:fieldext}, we provide a technique to boost soundness with minimal overhead, which applies to the three-move arithmetic circuit protocol in Section \ref{subsec:3rndsqrt}.

For each protocol, we will prove that with high probability, the \ILC\ query matrix for the protocol has full rank, and fewer rows than columns. This will be useful in Chapter \ref{chapterlabel:Compilation-Proof} when arguing that compiled protocols satisfy the zero-knowledge property.

\section{Polynomial Commitment Sub-Protocol} \label{subsec:polycommit}

The basis for the polynomial commitment protocol in this section was originally published in joint work \cite{BootleG18} with Jens Groth, as a discrete-logarithm based protocol.

We present an $\ILC~$ protocol that allows the prover to commit to a polynomial, so that the prover can later reveal the evaluation of the polynomial at a specific point $x$ chosen by the verifier and prove that the evaluation is correct. This protocol is the same as the polynomial commitment protocol in \cite{BootleG18}, and similar to the polynomial commitment protocol of \cite{BootleCCGP16}, but is rewritten slightly as an $\ILC~$ protocol.

\paragraph{Motivation.} It may seem unnecessary to produce a special protocol for committing to a polynomial and revealing the evaluation in the ILC model. After all, the prover could simply commit to each coefficient of the polynomial separately, and using a single query, the verifier could obtain an evaluation of the polynomial by requesting a single linear combination of the coefficients. However, the protocol in this subsection allows a trade-off between the number of commitments made by the prover, and the length of the vector which is given to the verifier as a response to the verifier's query. In most cases, this will lead to an improvement in communication complexity over the naive method of producing a separate commitment to each coefficient.

Looking ahead to the compilation of our \ILC\ protocols into real zero-knowledge protocols, the flexibility that the polynomial commitment protocol affords will be extremely useful. Our compilation based on hash-functions results in one commitment for each element of the longest committed vector. Our compilation based on the discrete-logarithm assumption results in one commitment for each committed vector. The polynomial commitment protocol allows a trade-off between these two dimensions, so that the same protocol can be tuned for each compilation method.

\subsection{Definitions}
A polynomial commitment scheme enables a prover to commit to a secret vector of polynomials $\vec{h}(X)$. Later on the verifier can learn the evaluation of the committed polynomial at a given point.

We add an integer argument $id$ to both the prover and verifier algorithms. Some protocols will use the polynomial commitment scheme more than once to commit to different polynomials, and the $id$ argument will allow the verifier to request the correct polynomial evaluation as part of $\mathrm{PolyVerify}$.

Let us discuss the algorithms in more detail. The public information available to both the prover and the verifier is $\crs = (\F,N)$ and $u = (m,l)$. Only the prover has access to a secret vector of polynomials $\vec{h}(X) \in \F^l[X]$ of degree $mn$. The verifier receives an evaluation point $x \in \F$ as input, and queries the \ILC\ to obtain some useful values. The verifier then outputs the evaluation $\vec{h}(x)$. The polynomial commitment scheme should be complete, knowledge-sound and special honest verifier zero-knowledge as defined below.

We will refer to the following relation, where ``PC" is short for polynomial commitment.

$$\R_{\textnormal{PC}}=\left\{\begin{array}{c}
(\crs,\stm,\wit)=\left( (\F,N)\ , \  (m,l) , \ \vec{h}(X) \right):\\
\vec{h}(X) \in \F^l[X] \text{ such that } \mathrm{deg}(\vec{h}(X)) = mn, \text{ where } N = nl
\end{array}\right\}.$$

The definition of completeness simply guarantees that if the protocol is carried out honestly, then the verifier will return the correct polynomial evaluation $\vec{h}(x)$.

\begin{definition}[Perfect Completeness]
The polynomial commitment scheme is \emph{perfectly complete} if for all PPT adversaries $\mathcal{A}$
$$\Pr \left[ \begin{array}{c} \crs\gets \KK(1^\sep); ((m,l),\vec{h}(X),x) \leftarrow \mathcal{A}(\crs): \\
(\crs,(m,l),\vec{h}(X))\notin \R_\mathrm{PC} ~\vee~ \langle \mathcal{P}(\crs,(m,l),\vec{h}(X))\overset{\ILC~}{\longleftrightarrow}\mathcal{V}(\crs,(m,l),x)\rangle= \vec{h}(x) \end{array}\right] =1.$$
\end{definition}

Knowledge soundness guarantees that the outputs of the protocol are in fact evaluations of the same polynomial.

\begin{definition}[Knowledge soundness]
A polynomial commitment scheme has \emph{knowledge soundness} if for all DPT $\Po^*$ there exists an expected PPT extractor $\E$ such that for all PPT adversaries $\A$
$$\Pr\left[\begin{array}{c} \crs\gets \KK(1^\sep);((m,l),s,x) \gets \mathcal{A}(\crs); \vec{h}(X) \gets \E^{\langle \Po^*(s)\overset{\ILC~}{\longleftrightarrow}\V(\crs,(m,l))\rangle}(\crs,(m,l),x):\\ \bar{\vec{h}} = \vec{h}(x) ~\wedge~ (\crs,(m,l),\vec{h}(X))\notin \R_\mathrm{PC} \end{array}\right]\approx 0.$$ 
Here the oracle $\langle \Po^*(s)\overset{\ILC~}{\longleftrightarrow}\V(\crs,(m,l))\rangle$ runs a full protocol execution and if the proof is successful it returns a transcript of the prover's communication with the channel. The extractor $\E$ can ask the oracle to rewind the proof to any point in a previous transcript and execute the proof again from this point on with fresh public-coin challenges from the verifier. We define $\bar{\vec{h}} \in \F^l$ to be the verifier's output in the first oracle execution. We think of $s$ as the state of the prover.
\end{definition}

Perfect special honest verifier zero-knowledge means that given any evaluation point $x$ and an evaluation $\vec{h}(x)$, it is possible to simulate the verifier's view so that the simulation is distributed exactly as in a real execution of the protocol, in a way that is consistent with the evaluation $\vec{h}(x)$.
\begin{definition}[Special Honest-Verifier Zero-Knowledge]
The polynomial commitment scheme is \emph{special honest-verifier zero-knowledge (SHVZK)} if there exists a PPT simulator $\mathcal{S}$ such that for all stateful interactive PPT adversaries $\mathcal{A}$ that output $((m,l),\vec{h}(X))$ such that $(\crs,u,w)\in \R_\mathrm{PC}$ and randomness $\rho$ for the verifier
\begin{eqnarray*}
&&\Pr \left[ \begin{array}{c}\crs\gets \KK(1^\sep);((m,l), \vec{h}(X),x, \rho) \leftarrow\mathcal{A}(\crs); \\
\viewV\leftarrow \langle \mathcal{P}(\crs,(m,l),\vec{h}(X))\overset{\ILC~}{\longleftrightarrow} \V(\crs,(m,l),x;\rho)\rangle: \A(\viewV)=1\end{array} \right]\\
&\approx
&\Pr \left[ \crs\gets \KK(1^\sep);((m,l), \vec{h}(X),x, \rho) \leftarrow\mathcal{A}(\crs); \viewV\leftarrow \mathcal{S}(\crs,(m,l),\vec{h}(x),x,\rho): \mathcal{A}(\viewV)=1\right].
\end{eqnarray*}
Note that $\vec{h}(x)$ appears as an input to the simulator.
\end{definition}

\subsection{Idea}

In the following, we will build a polynomial commitment scheme as in \ILC~ sub-protocol using vectors in $\F^{nl}$. Let us first give some intuition about how the construction will work. 

Let $\vec{h}(X)=\sum_{i=0}^N\vec{h}_iX^i$ be a polynomial of degree $N=(n+1)m-1$ with coefficients that are row-vectors in $\F^l$. Define an $m\times (n+1)l$ matrix $$
\left(\begin{array}{llll}
\vec{h}_{0,0} & \vec{h}_{0,1} &\cdots & \vec{h}_{0,n} \\
\vec{h}_{1,0} & \vec{h}_{1,1} & \cdots & \vec{h}_{1,n} \\
\vdots & \vdots &  \ddots & \\
\vec{h}_{m-1,0} & \vec{h}_{m-1,1} & \cdots &\vec{h}_{m-1,n}\\
\end{array} \right) = \left(\begin{array}{llll}
\vec{h}_0 & \vec{h}_{m} & \cdots & \vec{h}_{nm} \\
\vec{h}_1 & \vec{h}_{m+1} & \cdots & \vec{h}_{nm+1}\\
\vdots & \vdots & \ddots  & \\
\vec{h}_{m-1} & \vec{h}_{2m-1}  & \cdots  & \vec{h}_{N} \\
\end{array} \right)$$

With this matrix we have $\vec{h}(X)=\sum_{j=0}^n(\sum_{i=0}^{m-1}\vec{h}_{i,j}X^i)X^{mj}$. In the polynomial commitment scheme, the prover commits to each row of the matrix. Then, the verifier can make a single \ILC~ query to obtain $(\bar{\vec{h}}_0,\ldots,\bar{\vec{h}}_n) = \sum_{i=0}^{m} (\vec{h}_{i,0},\ldots,\vec{h}_{i,n}) x^i$. The verifier can use this value to compute $\vec{h}(x) = \bar{\vec{h}}_0+\sum_{j=1}^{n} \bar{\vec{h}}_{j} x^{(j-1)m+d}$.

While the main idea we have sketched above gives the verifier assurance that the committed polynomial has been correctly evaluated, the prover may not be happy. The problem is that the solution gives away information about the coefficients of $\vec{h}(X)$. We will therefore introduce some random blinding vectors to ensure no information is leaked about the committed coefficients except the evaluation of the polynomial. We will also adjust the protocol to handle an arbitrary polynomial degree $N=mn+d$ for $0\leq d<m$ by shifting the first column of the matrix.

We pick random blinders $\vec{b}_1,\ldots,\vec{b}_n\gets \F^l$ and define an $(m+1)\times (n+1)l$ matrix $\left\{ \vec{h}_{i,j} \right\}_{i=0,j=0}^{m,n}$ as follows:
$$\left(\begin{array}{lllll}
\vec{h}_0 & \vec{b}_{1} & \cdots & \vec{b}_{n-1} & \vec{b}_n \\
\vec{h}_1 & \vec{h}_{d+1} & \cdots & \vec{h}_{(n-2)m+d+1} & \vec{h}_{(n-1)m+d+1}\\
&&&& \vdots \\
\vec{h}_d-\vec{b}_1 & \quad \vdots & \ddots \quad & & \vec{h}_{nm}\\
0 &&&& \vec{h}_{nm+1}\\
\vdots &&&& \vdots  \\
0 & \vec{h}_{m+d-1}  & \cdots  & \vec{h}_{(n-2)m+d-1} & \vec{h}_{N-1} \\
0 & \vec{h}_{m+d}-\vec{b}_2 & \cdots & \vec{h}_{(n-2)m+d}-\vec{b}_n & \vec{h}_{N}
\end{array} \right)$$
We can therefore rewrite the polynomial as $$\vec{h}(X)=\sum_{i=0}^m\vec{h}_{i,0}X^i +\sum_{j=1}^{n} \left(\sum_{i=0}^m\vec{h}_{i,j}X^i \right)X^{(j-1)m+d}.$$

Then, in the polynomial commitment scheme, the prover can commit to each row as before, and the verifier's computation is also similar to that of the previous example. We describe the scheme below.

\subsection{Protocol}

\begin{description} \label{protpolycommit}
\item[$\textbf{P}_\mathrm{PC}(id)$:]
The prover randomly selects $\vec{b}_{1},\ldots,\vec{b}_{n} \gets \F^l$ and arranges them into a matrix with entries $\left\{\vec{h}_{i,j}\right\}_{i=0,j=0}^{m,n}$ as follows:
$$\left(\begin{array}{lllll}
\vec{h}_0 & \vec{b}_{1} & \cdots & \vec{b}_{n-1} & \vec{b}_n \\
\vec{h}_1 & \vec{h}_{d+1} & \cdots & \vec{h}_{(n-2)m+d+1} & \vec{h}_{(n-1)m+d+1}\\
&&&& \vdots \\
\vec{h}_d-\vec{b}_1 & \quad \vdots & \ddots \quad & & \vec{b}_n\\
0 &&&& \vec{h}_{nm+1}\\
\vdots &&&& \vdots  \\
0 & \vec{h}_{m+d-1}  & \cdots  & \vec{h}_{(n-2)m+d-1} & \vec{h}_{N-1} \\
0 & \vec{h}_{m+d}-\vec{b}_2 & \cdots & \vec{h}_{(n-2)m+d}-\vec{b}_n & \vec{h}_{N}
\end{array} \right)$$

The prover sends each row of the matrix above to \ILC\ (i.e. for $1 \leq i \leq m$, the prover sends the row vector $(\vec{h}_{i,0}||\ldots||\vec{h}_{i,n})$ to \ILC).

\item[$\textbf{V}_\mathrm{PC}(x,id)$:]

The verifier makes an \ILCopen\ query to the \ILC\ to obtain $(\bar{\vec{h}}_0,\ldots,\bar{\vec{h}}_n) = \sum_{i=0}^{m} (\vec{h}_{i,0},\ldots,\vec{h}_{i,n}) x^i$.

The verifier computes and returns $\vec{h}(x) = \bar{\vec{h}}_0+\sum_{j=1}^{n} \bar{\vec{h}}_{j} x^{(j-1)m+d}$.

\end{description}

\subsection{Security Proof}

\begin{lemma} \label{proofpolycommit}
The polynomial commitment protocol given above has perfect completeness, knowledge-soundness, and perfect special honest verifier zero-knowledge.
\end{lemma}
\begin{proof}
By inspection, it follows that when the prover is honest, the verifier always recovers $\bar{\vec{h}}=\vec{h}(x)$. 

We describe an efficient simulator to prove special honest verifier zero knowledge. The simulator is given $\vec{h}(x)$, and also given $\rho$, which determines the value of $x$. The simulator first picks random $\bar{\vec{h}}_1,\ldots,\bar{\vec{h}}_n\gets \F^l$ and then computes $\bar{\vec{h}}_0=\vec{h}(x)-\sum_{j=1}^n\bar{\vec{h}}_jx^{(j-1)m+d}$. In other words, the $\vec{h}_j$ are chosen uniformly at random, conditional on giving the correct evaluation $\vec{h}(x)$.

This is a perfect SHVZK simulation. The values $\bar{\vec{h}}_1,\ldots,\bar{\vec{h}}_n$ are chosen independently and uniformly at random in real proofs due to the choices of $\vec{b}_1,\ldots,\vec{b}_n$ just as in the simulated proofs. Finally, given these random values both real and simulated proofs, the matching $\bar{\vec{h}}_0$ are uniquely determined. This means we have identical distributions of real and simulated proofs which are consistent with the evaluation $\vec{h}(x)$.

Finally, we prove knowledge-soundness. The knowledge extractor already has access to the vectors committed as $(\vec{h}_{i,0}||\ldots||\vec{h}_{i,n})$ for $0 \leq i \leq m$, having seen all messages sent between the prover and the \ILC. Therefore, we define the polynomial to be $$\vec{h}(X)=\sum_{i=0}^m\vec{h}_{i,0}X^i +\sum_{j=1}^{n} \left(\sum_{i=0}^m\vec{h}_{i,j}X^i \right)X^{(j-1)m+d}$$
In the protocol, the verifier queries \ILC\ to obtain $(\bar{\vec{h}}_0,\ldots,\bar{\vec{h}}_n) = \sum_{i=0}^{m} (\vec{h}_{i,0},\ldots,\vec{h}_{i,n}) x^i$ and then computes and returns $\bar{\vec{h}} = \bar{\vec{h}}_0+\sum_{j=1}^{n} \bar{\vec{h}}_{j} x^{(j-1)m+d}$. Substituting the query values into the expression for $\bar{\vec{h}}$ shows that $\vec{h}(x) = \bar{\vec{h}}$ and completes the proof of soundness. \qed
\end{proof}

\begin{lemma}
The protocol has tree-special soundness, and the extraction algorithm $\chi$ is a linear map.
\end{lemma}

\begin{proof}
The verifier's view takes the form $(\bar{\vec{h}}_0,\ldots,\bar{\vec{h}}_n) = \sum_{i=0}^{m} (\vec{h}_{i,0},\ldots,\vec{h}_{i,n}) x^i$. This corresponds to case 1 of Lemma \ref{lem:linextract}. Therefore, given the verifier's view for sufficiently many distinct values of $x$, one can recover the committed polynomial using a linear map.
\end{proof}

\begin{lemma}
With high probability, the \ILC\ query matrix for the protocol has full rank, and fewer rows than columns.
\end{lemma}

\begin{proof}
The rows of the query matrix correspond to the number of \ILC\ queries made by the verifier. The columns correspond to vectors which the prover has committed to. In this protocol, there is only one query, so there are clearly fewer queries than commitments whenever $m$ is greater than $1$. The query matrix consists of only a single vector, and is therefore full rank whenever the query matrix is non-zero. With high probability over the choice of $x$, the query is non-trivial.
\end{proof}

\subsection{Efficiency}

\paragraph{Communication.} The prover must send $m+1$ vectors in $\F^{nl}$ to \ILC. The verifier receives a single vector of length $N = nl$ from \ILC.

\paragraph{Computation.} The prover does not need to do any algebraic computation. The verifier's computation is dominated by the $ml$ multiplications over $\F$ required to compute $\vec{h}(x)$. It costs the \ILC~ $mnl$ multiplications to compute the verifier's query.

\section{3-Move Low Depth Circuit Protocol} \label{subsec:3rndlowdeg}

The basis for the protocol in this section was originally published in joint work \cite{BootleG18} with Jens Groth, as a discrete-logarithm based protocol.

We present an \ILC\ protocol that allows the prover to prove knowledge of values which satisfy a polynomial relation of low-degree. This type of relation is useful when giving zero-knowledge membership and non-membership proofs, such as the membership proof in \cite{GrothK15}, its subsequent optimisation in \cite{BootleCCGGP15}, and the polynomial evaluation proof of \cite{BayerG13}. This protocol is the same as the main protocol given in \cite{BootleG18}, but is rewritten slightly as an $\ILC~$ protocol.

The idea is to prove that the prover knows solutions to polynomial relations encoding various statements, but allow the statements to be tweaked through an extra input to the polynomial. Let $\lbrace \vec{b}_{i,j} \rbrace_{i\in[m],j\in[n]}$ be some public vectors, representing the extra inputs or `tweaks'. Let $\vec{P}$ and $\vec{Q}$ be vectors of polynomials which take two inputs, $\lbrace \vec{a}_{i,j}, \vec{b}_{i,j} \rbrace_{i\in[m],j\in[n]}$. We assume that the prover has already committed to $C$ which we will write with square brackets in the instance $[C]$. We give a proof of knowledge of values $\lbrace \vec{a}_{i,j} \rbrace_{i\in[m],j\in[n]}$, such that $\vec{P}(\vec{a}_{i,j},\vec{b}_{i,j})=\vec{0}$ for $i \in [m], j \in [n]$, and such that
$$C = \left(\begin{array}{lll}
\vec{Q}(\vec{a}_{1,1},\vec{b}_{1,1}),&\vec{Q}(\vec{a}_{1,2},\vec{b}_{1,2}),& \ldots,\vec{Q}(\vec{a}_{1,n},\vec{b}_{1,n}) \\
\vec{Q}(\vec{a}_{2,1},\vec{b}_{2,1}),&\vec{Q}(\vec{a}_{2,2},\vec{b}_{2,2}),& \ldots,\vec{Q}(\vec{a}_{2,n},\vec{b}_{2,n}) \\
\vdots \\
\vec{Q}(\vec{a}_{m,1},\vec{b}_{m,1}),&\vec{Q}(\vec{a}_{m,2},\vec{b}_{m,2}),& \ldots,\vec{Q}(\vec{a}_{m,n},\vec{b}_{m,n}) \\
\end{array}\right)$$
The protocol we design will be more efficient than repeating $t=mn$ instances of the basic protocol in parallel, as the communication complexity will depend on $\sqrt{t}$ rather than $t$.

In the following we will refer to the parameters $\ell_a,\ell_b,\ell_P,d_P,\ell_Q,d_Q$ such that $\vec{a}_{i,j}\in \F^{\ell_a}$, $\vec{b}_{i,j}\in \F^{\ell_b}$, $\vec{P}$ is a vector of length $\ell_P$ with entries $(\ell_a+\ell_b)$-variate polynomials of total degree $d_P$, and $\vec{Q}$ is a vector of length $\ell_Q$ containing $(\ell_a+\ell_b)$-variate polynomials of total degree $d_Q$.

The relation corresponding to the proof is as follows, where ``LD" is short for ``low-depth". $$\R_\mathrm{LD}= \left\{\begin{array}{c}
(\crs,\stm,\wit)=\left( (\F,n,z_1,\ldots,z_m)\ , \  ([C],\vec{P},\vec{Q},\lbrace \vec{b}_{i,j} \rbrace_{i \in [n], j \in [m]}), \lbrace \vec{a}_{i,j} \rbrace_{i \in [n], j \in [m]} \right):\\
\forall i \in [m], \forall j \in [n], \vec{P}(\vec{a}_{i,j},\vec{b}_{i,j})=\vec{0} \\
C = \left(\begin{array}{lll}
\vec{Q}(\vec{a}_{1,1},\vec{b}_{1,1}),&\vec{Q}(\vec{a}_{1,2},\vec{b}_{1,2}),& \ldots,\vec{Q}(\vec{a}_{1,n},\vec{b}_{1,n}) \\
\vec{Q}(\vec{a}_{2,1},\vec{b}_{2,1}),&\vec{Q}(\vec{a}_{2,2},\vec{b}_{2,2}),& \ldots,\vec{Q}(\vec{a}_{2,n},\vec{b}_{2,n}) \\
\vdots \\
\vec{Q}(\vec{a}_{m,1},\vec{b}_{m,1}),&\vec{Q}(\vec{a}_{m,2},\vec{b}_{m,2}),& \ldots,\vec{Q}(\vec{a}_{m,n},\vec{b}_{m,n}) \\
\end{array}\right)
\end{array}\right\}.$$

\subsection{Intuition behind Protocol}
The protocol embeds multiple instances of the same polynomial equality into a single polynomial by using Lagrange interpolation polynomials, inspired by \cite{Gennaro2013,Bayer2014}. To recover a single instance, simply evaluate the polynomial in one of the interpolation points.

More concretely, the prover commits to the following vectors.
$$\begin{array}{llllll}
(\vec{a}_{0,1}||&\vec{a}_{0,2}||&\ldots||&\vec{a}_{0,n}) \\
(\vec{a}_{1,1}||&\vec{a}_{1,2}||&\ldots||&\vec{a}_{1,n}) \\
(\vec{a}_{2,1}||&\vec{a}_{2,2}||&\ldots||&\vec{a}_{2,n}) \\
\;\vdots \\
(\vec{a}_{m,1}||&\vec{a}_{m,2}||&\ldots||&\vec{a}_{m,n}) \\
\end{array}$$
Here, the values $\vec{a}_{0,1},\ldots,\vec{a}_{0,n} \in \F^{l_a}$, where the value of the first index is $0$, are blinding values chosen uniformly at random. These are completely unrelated to the values of the witness, which are $\vec{a}_{1,1},\ldots,\vec{a}_{m,n}$, where the first index has a value strictly greater than $0$. The verifier chooses a random challenge $x$ and queries the \ILC~ to obtain $(\bar{\vec{a}}_1,\ldots,\bar{\vec{a}}_n) = \sum_{i=0}^m (\vec{a}_{i,1},\ldots,\vec{a}_{i,n}) l_i(x)$.

We must demonstrate that $\vec{a}_{i,j}, \vec{b}_{i,j}$ satisfy the polynomial relations in the statement. Let $\bar{\vec{b}}_j = \sum_{i=1}^m \vec{b}_{ij} l_i(x)$. The verifier evaluates $\vec{P}$, $\vec{Q}$ using $\bar{\vec{a}}_j$ and $\bar{\vec{b}}_j$ for each $j$. By definition of $\bar{\vec{a}}_j$ and $\bar{\vec{b}}_j$, when evaluating at an interpolation point $z_i$, we obtain the single evaluation of the original polynomial, $\vec{P}(\vec{a}_{i,j},\vec{b}_{i,j})$. This implies, for example, that $\vec{P}(\bar{\vec{a}}_j,\bar{\vec{b}}_j) \equiv \vec{0} \mod l_0(x)$, or in other words, that $\vec{P}(\bar{\vec{a}}_j,\bar{\vec{b}}_j)$ is a multiple of $l_0(X)$ for each $j$. The prover must commit to the coefficients of $\vec{P}(\bar{\vec{a}}_j,\bar{\vec{b}}_j) / l_0(x)$ in advance (as a polynomial in $x$), and uses the polynomial commitment scheme to achieve this for every $j$ simultaneously.

Finally, the prover needs to convince the verifier that the committed matrix $C$ contains the values of $\vec{Q}(\vec{a}_{i,j},\vec{b}_{i,j})$. This is done in a similar way to the $\vec{P}$ polynomial, except here we build up polynomial equalities over committed values. The full protocol can be found below.

\begin{description} \label{protmultiversion}
\item[Common Reference String:] $\crs=(\F,n,k_1,t_1,z_1,\ldots,z_m)$ where $z_1,\ldots,z_m$ are distinct points in $\F$ defining Lagrange polynomials $l_1(X),\ldots,l_m(X)$ such that $l_i(z_j)=\delta_{i,j}$ and defining $l_0(X)=\prod_{j=1}^m(X-z_j)$.
%
\item[Instance:] $\lbrace \vec{b}_{i,j} \rbrace_{i \in [m], j \in [n]}, \vec{P},\vec{Q}$ polynomials, and the $[C]$ that are already stored in the \ILC.
%
\item[P:]
Pick $\vec{a}_{0,1},\ldots,\vec{a}_{0,n}\gets \F^{\ell_a}$ and $\vec{c}_{0,1},\ldots,\vec{c}_{0,n}\gets \F^{\ell_Q}$. Send $(\vec{c}_{0,1}||\ldots||\vec{c}_{0,n})$ to \ILC. Also send $\left( \vec{a}_{i,1}||\ldots||\vec{a}_{i,n}\right)$ for $i\in \{0\}\cup [m]$ to \ILC.

Define
$$\begin{array}{lll}
\bar{\vec{a}}_{j}(X) = \sum_{i=0}^m \vec{a}_{i,j} l_i(X) & \qquad &
\bar{\vec{b}}_{j}(X) = \sum_{i=1}^m \vec{b}_{i,j} l_i(X) \\ \\
\vec{P}_j^*(X)=\frac{\vec{P}\left(\bar{\vec{a}}_j(X),\bar{\vec{b}}_j(X)\right)}{l_0(X)} & & \vec{Q}_j^*(X)=\vec{c}_{0,j}+\frac{\sum_{i=1}^m\vec{Q}(\vec{a}_{i,j},\vec{b}_{i,j})l_i(X)-\vec{Q}\left(\bar{\vec{a}}_j(X),\bar{\vec{b}}_j(X)\right)}{l_0(X)}
\end{array}$$

Run $\textbf{P}_\mathrm{PC}(\crs=(\F,k_1),id=1)$ and commit to $\left( \vec{P}_1^*(X)||\ldots||\vec{P}_n^*(X)\right)$.

Run $\textbf{P}_\mathrm{PC}(\crs=(\F,t_1),id=2)$ and commit to $\left( \vec{Q}_1^*(X)||\ldots||\vec{Q}_n^*(X)\right)$.

\item[V:] The verifier samples the challenge $x \gets \F\setminus\{z_1,\ldots,z_m\}$ randomly.
The verifier runs
\begin{align*}
\textbf{V}_\mathrm{PC}(x,id=1) \to \bar{\vec{p}}=(\bar{\vec{p}}_1,\ldots,\bar{\vec{p}}_n) &&
\textbf{V}_\mathrm{PC}(x,id=2) \to \bar{\vec{q}}=(\bar{\vec{q}}_1,\ldots,\bar{\vec{q}}_n)
\end{align*}
Let $\vec{c}_i = (\vec{c}_{i,1}|| \ldots || \vec{c}_{i,n} )$ denote the rows of $C$, where $\vec{c}_{i,j} \in \F^{\ell_Q}$. The verifier makes a \ILCopen\ query for the following value.
\begin{align*}
(\bar{\vec{a}}_1||\ldots||\bar{\vec{a}}_n) &= \sum_{i=0}^m ( \vec{a}_{i,1}||\ldots||\vec{a}_{i,n}) {l_i(x)}
\end{align*}
The verifier computes $\bar{\vec{b}}_j=\bar{\vec{b}}_j(x)$. The verifier performs the following checks.
\begin{align*}
(\vec{P}(\bar{\vec{a}}_j,\bar{\vec{b}}_j))_{j \in [n]} &\vereq \bar{\vec{p}} l_0(x) \\
(\bar{\vec{q}}_jl_0(x)+\vec{Q}(\bar{\vec{a}}_j,\bar{\vec{b}}_j))_{j \in [n]} &\vereq \sum_{i=0}^m ( \vec{c}_{i,1}||\ldots||\vec{c}_{i,n}) {l_i(x)}
\end{align*}
The first check is made directly. The second check uses one \ILCcheck\ query.
If all checks are satisfied, then the verifier outputs $1$, and otherwise $0$.
\end{description}

\begin{lemma} \label{proofmultiversion}
The protocol has perfect completeness, knowledge-soundness, and perfect special honest verifier zero-knowledge.
\end{lemma}

\begin{proof}
Perfect completeness of the protocol follows by perfect completeness of the PolyCommit sub-protocol, which was used to commit to $\left( \vec{P}_1^*(X)||\ldots||\vec{P}_n^*(X)\right)$ and $\left( \vec{Q}_1^*(X)||\ldots||\vec{Q}_n^*(X)\right)$, and by careful inspection.

For perfect special honest verifier zero knowledge, we provide an efficient simulator for the protocol. The simulator selects $\bar{\vec{a}}_j \gets \F^{\ell_a}$ and $\bar{\vec{q}}_j\gets \F^{\ell_Q}$ for each j. All these values are distributed exactly as in a real protocol, where they are also uniformly random. She then simulates the view of the verifier when running $\verifier_\mathrm{PC}(x,id=1)$ and $\verifier_\mathrm{PC}(x,id=2)$ using the evaluation point $x$ and evaluations $\bar{\vec{p}}$ and $\bar{\vec{q}}$, which are determined by the values already simulated. By the perfect SHVZK of the polynomial commitment scheme, the simulated values have identical distribution to the real proofs.

Finally, we prove knowledge-soundness. The \ILC~ knowledge extractor already has access to all messages sent between the prover and \ILC. It remains to show that if the committed values are not a valid witness, then there is a negligible probability that the verifier will accept.
Recall the verification checks. The verifier runs
\begin{align*}
\verifier_\mathrm{PC}(x,id=1) \to \bar{\vec{p}}=(\bar{\vec{p}}_1,\ldots,\bar{\vec{p}}_n) &&
\verifier_\mathrm{PC}(x,id=2) \to \bar{\vec{q}}=(\bar{\vec{q}}_1,\ldots,\bar{\vec{q}}_n)
\end{align*}
The verifier queries \ILC~ to obtain the following values.
\begin{align*}
(\bar{\vec{a}}_1||\ldots||\bar{\vec{a}}_n) &= \sum_{i=0}^m ( \vec{a}_{i,1}||\ldots||\vec{a}_{i,n}) {l_i(x)} \\
(\bar{\vec{c}}_1||\ldots||\bar{\vec{c}}_n) &= \sum_{i=0}^m ( \vec{c}_{i,1}||\ldots||\vec{c}_{i,n}) {l_i(x)}
\end{align*}
The verifier computes $\bar{\vec{b}}_j=\bar{\vec{b}}_j(x)$. The verifier performs the following checks, for all $j \in [n]$.
\begin{align*}
\vec{P}(\bar{\vec{a}}_j,\bar{\vec{b}}_j) \vereq \bar{\vec{p}}_jl_0(x) &&
\bar{\vec{q}}_jl_0(x)+\vec{Q}(\bar{\vec{a}}_j,\bar{\vec{b}}_j) \vereq \bar{\vec{c}}_j
\end{align*}
Now, substitute the expressions for $\bar{\vec{a}}_j$, $\bar{\vec{b}}_j$ and $\bar{\vec{c}}_j$ into the left-hand side of the verification equations. By the soundness of the polynomial commitment protocol, we know that $\vec{p}_j$ is a polynomial of degree $m (d_P-1)$ in $x$, and that $\vec{q}_j$ is a polynomial of degree $m(d_Q-1)$ in $x$. The verifier only accepts if the equations hold. By assumption $\PoProdMal$ is deterministic, and we know when it made its commitments. Hence, $\vec{a}_{i,j}$, $\vec{b}_{i,j}$ and $\vec{c}_{i,j}$ are constants. By the soundness of the polynomial commitment protocol, and the fact that the polynomials were committed by the prover before seeing $x$, we know that $\vec{p}_j$ is a polynomial of degree $m (d_P-1)$ in $x$, and that $\vec{q}_j$ is a polynomial of degree $m(d_Q-1)$ in $x$.

We can now apply Lemma~\ref{lem:szvariant}, which implies the Schwarz-Zippel Lemma. Suppose that there exist $i$ and $j$ such that
\begin{align*}
\vec{P}(\vec{a}_{i,j},\vec{b}_{i,j}) \neq 0 & \quad \text{ or } \quad \vec{Q}(\vec{a}_{i,j},\vec{b}_{i,j}) \neq \vec{c}_{i,j}
\end{align*}
This implies that
\begin{align*}
\vec{P}(\bar{\vec{a}}_j(X),\bar{\vec{b}}_j(X)) \neq \bar{\vec{p}}_j(X)l_0(X) & \quad \text{ or } \quad \bar{\vec{q}}_j(X)l_0(X)+\vec{Q}(\bar{\vec{a}}_j(X),\bar{\vec{b}}_j(X)) \neq \bar{\vec{c}}_j(X)
\end{align*}
By the Schwarz-Zippel Lemma, if there is not an equality of polynomials, then the probability that that verification checks are satisfied is $\max (d_P,d_Q) m / |\F|$. The verifier can only accept if we have equality, so this shows that the probability that the committed values does not satisfy the product relation but that the verifier accepts is negligible, which proves knowledge soundness.\qed
\end{proof}

\begin{lemma}
The protocol has tree-special soundness, and the extraction algorithm $\chi$ is a linear map.
\end{lemma}

\begin{proof}
The verifier sees the following queries as part of the protocol.
\begin{align*}
(\bar{\vec{a}}_1||\ldots||\bar{\vec{a}}_n) &= \sum_{i=0}^m ( \vec{a}_{i,1}||\ldots||\vec{a}_{i,n}) {l_i(x)} \\
(\bar{\vec{c}}_1||\ldots||\bar{\vec{c}}_n) &= \sum_{i=0}^m ( \vec{c}_{i,1}||\ldots||\vec{c}_{i,n}) {l_i(x)}
\end{align*}
These both correspond to case 2 of Lemma \ref{lem:linextract}. Therefore, given the verifier's view for sufficiently many distinct values of $x$, one can recover the committed polynomial using a linear map. \qed
\end{proof}

\begin{lemma}
With high probability, the \ILC\ query matrix for the protocol has full rank, and fewer rows than columns.
\end{lemma}

\begin{proof}
The rows of the query matrix correspond to the number of \ILC\ queries made by the verifier. The columns correspond to vectors which the prover has committed to. In this protocol, there are a constant number of queries, including the queries from the polynomial commitment sub-protocol, so there are clearly fewer queries than commitments whenever $m$ is large enough. The query matrix has full rank. This is because the two submatrices corresponding to the polynomial commitment sub-protocols have full rank. The submatrix corresponding to the main protocol also has full rank, since the two queries are non-trivial and operate on different commitments. Since each sub-matrix operates on different commitments to each other, the entire query matrix has full rank. With high probability over the choice of $x$, all queries are non-trivial. \qed
\end{proof}

\subsection{Communication} Let $k_1,k_2$ be the dimensions of the matrix used in the PolyCommit subprotocol when committing to $\vec{P}^*$, and similarly, let $t_1,t_2$ be the dimensions of the matrix in the subprotocol for committing to $\vec{Q}^*$. In total, the prover commits to $m+k_1+t_1+4$ vectors using \ILC~ ($k_1$ vectors of length $k_2$, $t_1$ vectors of length $t_2$, and $m$ vectors of length $n$). The verifier's queries amount to a total of $\ell_a n + \ell_P n (k_2+1) + \ell_Q n (t_2+1) + 4$ field elements. The verifier makes $3$ queries to \ILC, with queries on vectors of lengths $k_2$, $t_2$ and $n$ respectively.

\paragraph{Single Proof Case} When $t=mn=1$ and the prover is proving a single relation, we may choose parameters so that the protocol only sends a constant number of vectors to \ILC. This will be useful for the compiled proofs, where commitments often use extremely large group elements. Set $k_1 = t_1 = 1$, $k_2 = d_P-1$, $t_2 = d_Q-1$. Then the prover need only send $7$ vectors to \ILC. The verifier's queries amount to a total of $\ell_a + \ell_P d_P + \ell_Q d_Q + 4$ field elements. This will minimise communication in the case where the protocol is compiled and instantiated over a multiplicative subgroup of a finite field, where group elements are much bigger than field elements.

In the case where the protocol is later instantiated using an elliptic curve group, commitments and field elements have roughly the same size. Then, we can minimise the total communication costs by choosing $k_2 =\left\lceil \sqrt{\frac{d_P }{\ell_P }} ~\right\rceil$, $k_1 \approx \frac{d_P }{k_2}$. Set $t_2= \left\lceil \sqrt{\frac{d_Q}{\ell_Q}} ~\right\rceil$, $t_1 \approx \frac{d_Q }{t_2}$. Then the prover must send $\sqrt{\ell_P d_P}+\sqrt{\ell_Q d_Q} + 5$ vectors to \ILC. The verifier's queries amount to a total of $\ell_a + \sqrt{\ell_P d_P}+\sqrt{\ell_Q d_Q} + 4$ field elements. 

\paragraph{Batch Proof Case} When $t$ is large, we choose parameters so that the communication costs in compiled proofs are proportional to $\sqrt{t}$ rather than $t$. Set $k_2 =\left\lceil \sqrt{\frac{d_P m}{\ell_P n}} ~\right\rceil$, $k_1 \approx \frac{d_P m}{k_2}$. Set $t_2 =\left\lceil \sqrt{\frac{d_Q m}{\ell_Q n}} ~\right\rceil$, $t_1 \approx \frac{d_Q m}{t_2}$. Finally, set $m \approx \sqrt{\ell_a t}, n \approx \frac{t}{m}$. Then the protocol requires the prover to send roughly $\sqrt{\ell_a t} + \sqrt{d_P \ell_P t} + \sqrt{d_Q \ell_Q t}$ vectors to \ILC. The verifier's queries amount to a total of $\sqrt{\ell_a t} + \sqrt{d_P \ell_P t} + \sqrt{d_Q \ell_Q t}$ field elements.

\subsection{Computation} 
Over $\F$, the prover must perform$$O( (\ell_a+\ell_b+\ell_P) td_P \log md_P +(\ell_a+\ell_b+\ell_Q) td_Q \log md_Q + td_P \mathsf{Eval}_P+td_Q \mathsf{Eval}_Q)$$ multiplications. Here, $\mathsf{Eval}_P$ is the cost of evaluating $P$ once, and similarly for $Q$. The vectors of polynomials $\vec{P}^*(X),\vec{Q}^*(X)$ are computed using FFT techniques.
Over $\F$, the verifier must perform $O( (\ell_P+\ell_Q)n +  n\mathsf{Eval}_P+n \mathsf{Eval}_Q)$ multiplications. To compute the verifier's queries, the \ILC~ uses $\ell_P d_P mn + \ell_Q d_Q mn$ multiplications to compute the verifier's polynomial commitment queries, and $mn(\ell_a+\ell_b)$ multiplications to compute the verifier's other \ILC\ queries.

\subsection{Applications}

In this section, we specify concrete choices of relations for $\vec{P},\vec{Q}$, which give rise to zero-knowledge arguments for several useful applications.

\subsubsection{Membership Argument with Public List}\label{app:member}
In membership arguments~\cite{BS01,BDD07}, the prover wishes to convince the verifier that a commitment contains one of the values in a given list $\mathcal{L}=(\lambda_0,\ldots,\lambda_{N-1})$. Groth and Kohlweiss~\cite{GrothK15} give an efficient membership argument, which with minor tweaks fits into our framework. For simplicity, we will in the following assume $N$ is a power of 2.
\begin{description}
\item[ Statement: ] $([c],\lambda_0,\ldots,\lambda_{N-1})$
\item[ Witness: ] $\ell$ such that $c =\lambda_\ell$
\item[ Polynomial Encoding: ] Let $m = \log_2 N$ and let $(l_0,\ldots,l_{m-1})$ be the binary expansion of $l$, satisfying $l_j ( 1 - l_j) = 0$ for $0 \leq j \leq m-1$. Define $l_{j,1} :=l_j$ and $l_{j,0} = 1-l_j$. We have that $$\sum_{i=0}^{N-1} \lambda_i \prod_{j=0}^{m-1} l_{j,i_j} = \lambda_l $$ where we write the binary expansion of $i$ as $(i_0,\ldots,i_{m-1})$.
\item[ Parameter Choice: ] Writing $\circ$ for the entry-wise product of two vectors
\begin{itemize}
\item $\ell_a=\log_2 N, \ell_b=N, \ell_P=\log_2 N, d_P=2, \ell_Q=1, d_Q=\log_2 N$ 
\item $\vec{a} = (l_0,\ldots,l_{m-1})$
\item $\vec{b} = (\lambda_0,\ldots,\lambda_{N-1})$
\item $\vec{P}(\vec{a},\vec{b}) = \vec{a} \circ ( \vec{1} - \vec{a} )$
\item $Q(\vec{a},\vec{b}) = \sum_{i=0}^{N-1} \lambda_i \prod_{j=0}^{m-1} l_{j,i_j}$
\end{itemize}
\end{description}

An alternative construction was given in \cite{BootleCCGGP15} that optimises the membership argument by using an $n$-ary representation of $l$. This alternative construction is captured by our framework as follows, this time assuming for simplicity that $N$ is a power of $n$, using different polynomials $\vec{P}$ and $\vec{Q}$.
\begin{description}
\item[ Polynomial Encoding: ] Let $m = \log_n N$ and let $(l_0,\ldots,l_{m-1})$ be the $n$-ary expansion of $l$. Let $\delta_{rs}$ be the Kronecker delta symbol, which is equal to $1$ if $r=s$ and $0$ otherwise. Consider the bit-string $(\delta_{l_0,0},\delta_{l_0,1},\ldots,\delta_{l_{m-1},n-1})$, each element satisfying $\delta_{i,j} ( 1 - \delta_{i,j}) = 0$, and with $\sum_{i=0}^{n-1} \delta_{l_j,i} = 1$ for each $j$. As described in \cite{BootleCCGGP15}, we have that $$\sum_{i=0}^{N-1} \lambda_i \prod_{j=0}^{m-1} \delta_{j,i_j} = \lambda_l $$ where $i_j$ the $j$th $n$-ary digit of $i$.
\item[ Parameter Choice: ] \ 
\begin{itemize}
\item $\ell_a=n\log_nN$, $\ell_b=N$, $\ell_P=n\log_nN$, $d_P=2$, $\ell_Q=1$, $d_Q=\log_nN$
\item $\vec{a} = (\delta_{l_0,1},\ldots,\delta_{l_{m-1},n-1})$, not including $\delta_{j,0}$ for any $j$.
\item $\vec{b} = (\lambda_0,\ldots,\lambda_{N-1})$.
\item $\delta_{l_j,0} = 1 - \sum_{i=1}^{n-1} \delta_{l_j,i}$ for each $j$.
\item $\vec{v} = \left( \delta_{l_0,0},\ldots,\delta_{l_{m-1},n-1} \right)$, with the $\delta_{j,0}$ included.
\item $P(\vec{a},\vec{b}) = \vec{v} \circ ( \vec{1} - \vec{v} )$
\item $Q(\vec{a},\vec{b}) = \sum_{i=0}^{N-1} \lambda_i \prod_{j=0}^{m-1} \delta_{j,i_j} = \lambda_l$
\end{itemize}
\end{description}

When $t=1$ and we are aiming for a constant number of commitments, the simple binary version of the argument gives the lowest communication costs. Otherwise, in the cases where $t$ is large, or where $t=1$ and we aim to minimise the total number of elements communicated in the compiled proof, setting $n=3$ gives the lowest communication costs. The protocol efficiency is reported in Table~\ref{taEfficiency8}.

\subsubsection{Polynomial Evaluation Argument}\label{app:poly}
In a polynomial evaluation argument~\cite{FO97,BDD07}, we have a polynomial of degree $N$ and commitments to a point and its purported evaluation in that point. The prover wants to convince the verifier that the committed evaluation of the polynomial is correct. 

The most efficient discrete logarithm based polynomial evaluation argument was given by Bayer and Groth~\cite{BayerG13}. We will now use our framework of polynomial relations to capture their protocol.
\begin{description}
\item[ Statement: ] $([c_u],[c_v],h(X))$, where $h(X)$ is a polynomial of degree $N$.
\item[ Witness: ] $u,v$ such that $c_u = u, c_v = v$, and $h(u) = v$.
\item[ Polynomial Encoding: ] Set $u_i = u^{2^i}$ for $0 \leq i \leq \log_2 N - 1$, so that $u_i = u_{i-1}^2$ for each $i$. If $h(X) = \sum_{i=0}^{N-1} h_i X^i$, then we can write $h(u) = \sum_{i=0}^{N-1} h_i \prod_{j=0}^{\log_2 N - 1} u_j^{i_j}$.
\item[ Parameter Choice: ] \ 
\begin{itemize}
\item $\ell_a=\log_2 N$, $\ell_b=N$, $\ell_P=\log_2 N-1$, $d_P=2$, $\ell_Q=1$, $d_Q=\log_2 N$
\item $\vec{a} = (u_0,\ldots,u_{\log N-1})$
\item $\vec{b} = (h_0,\ldots,h_{N-1})$
\item $\vec{P}(\vec{a},\vec{b}) = (u_1 - u_0^2, \ldots, u_{\log N-1} - u_{\log N-2}^2)$
\item $\vec{Q}(\vec{a},\vec{b}) = \sum_{i=0}^{N-1} h_{i} \prod_{j=0}^{\log N-1} u_j^{i_j}$
\end{itemize}
\end{description}

With alternative choices of the matrices $\vec{P},\vec{Q}$, we can improve the communication costs of their argument by switching to an $n$-ary encoding of the powers in the polynomial.
\begin{description}
\item[ Polynomial Encoding: ] Set $u_i = u^{n^i}$ for $0 \leq i \leq \log_n N - 1$, so that $u_i = u_{i-1}^n$ for each $i$. If $h(X) = \sum_{i=0}^{N-1} h_i X^i$, then we can write $h(u) = \sum_{i=0}^{N-1} h_i \prod_{j=0}^{\log_n N - 1} u_j^{i_j}$, where this time, $i_j$ is the $j$th digit of the $n$ary representation of $i$. This gives rise to the efficiencies listed in Table~\ref{taEfficiency}.
\item[ Parameter Choice: ] \ 
\begin{itemize}
\item $\ell_a=\log_nN$, $\ell_b=N$, $\ell_P=\log_n N$, $d_P=n$, $\ell_Q=1$, $d_Q=\log_n N$
\item $\vec{a} = (u_0,\ldots,u_{\log_n N-1})$
\item $\vec{b} = (h_0,\ldots,h_{N-1})$
\item $\vec{P}(\vec{a},\vec{b}) = (u_1 - u_0^n, \ldots, u_{\log_n N-1} - u_{\log_n N-2}^n)$
\item $\vec{Q}(\vec{a},\vec{b}) = \sum_{i=0}^{N-1} h_{i} \prod_{j=0}^{\log_n N-1} u_j^{i_j}$
\end{itemize}
\end{description}

When $t=1$ and we are aiming for a constant number of commitments, setting $n=4$ gives the lowest communication costs. When $t=1$ and we aim to minimise the total number of elements communicated in the compiled proof, we set $n = \frac{\log_2N}{\log_2 \log_2 N}$. Otherwise, in the cases where $t$ is large, setting $n=6$ gives the lowest communication costs. The protocol efficiency is reported in Table~\ref{taEfficiency9}. 

We would like to highlight the results when $t=1$ and $n = \frac{\log_2N}{\log_2 \log_2 N}$. In this case, the total communication complexity of the polynomial evaluation protocol is $O\left(\frac{\log N}{\log \log N}\right)$ commitments and field elements in the discrete logarithm settting. In particular, this protocol has the best asymptotic efficiency for polynomial evaluation in zero-knowledge based on the discrete-logarithm assumption. If we use the polynomial to specify a set through its roots, then argument gives a membership argument where the communication costs are asymptotically less than $\log N$, the number of bits required to specify an element of the set. The best known arguments for general arithmetic circuits \cite{BootleCCGP16,BunzBBPWM18} achieve a logarithmic communication complexity, as the number of multiplication gates required to compute a polynomial of degree $N$ is $N$. This protocol also uses commitments to vectors of length $O(\log N)$ rather than $O(N)$ which translates to dramatically fewer cryptographic operations.

We note that \cite{Bayer2014} gives a batch argument for polynomial evaluation based on similar ideas. However, ours is more communication efficient.

\paragraph{Remark.} The relations above arise from choices of a small set of powers of $u$ which generate all powers from $u$ to $u^{N-1}$. This is the same as choosing an additive basis for $[N-1]$. For certain parameter choices, we have found modest benefits to using more complex bases, such as generalised Zeckendorf bases, but these give only slight improvements, so are omitted for simplicity.

\subsubsection{Range Proof}\label{app:range}
In range proofs~\cite{Bou02,Lip03}, we have a commitment and a range $[A;B]$. The prover wants to convince the verifier that the committed value inside the commitment falls in the given range. A common strategy for constructing a range proof is to write the committed value in binary, prove all the bits are indeed 0 or 1, and that their weighted sum yields a number within the range. We now describe this type of range proof in our framework of polynomial relations, where we for simplicity focus on intervals $[0,N]$ with $N = 2^{m}-1$.

\begin{description}
\item[ Statement: ] $(N,[c])$
\item[ Witness: ] $a,r$ such that $c = a, a \in [0,N]$.
\item[ Polynomial Encoding: ] Let $a_0,\ldots,a_{m-1}$ be the binary representation of $a$, so that $a_i ( 1 - a_i ) = 0$ for $0 \leq i \leq m-1$. Then $a = \sum_{i=0}^{m-1} a_i 2^i$.
\item[ Parameter Choice: ] \ 
\begin{itemize}
\item $\ell_a=m, \ell_b=m, \ell_P=m, d_P=2, \ell_Q=1, d_Q=m+1$
\item $\vec{a} = (a_0,\ldots,a_{m-1})$
\item $\vec{b} = (2^0,2^1,\ldots,2^{m-1})$
\item $\vec{P}(\vec{a},\vec{b}) = \vec{a} \circ ( \vec{1} - \vec{a} ) $
\item $\vec{Q}(\vec{a},\vec{b}) = \sum_{i=0}^{m-1} a_i 2^i$
\end{itemize}
\end{description}

With an alternative choice of $\vec{P},\vec{Q}$, following \cite{Chaabouni2010}, it is possible to improve the communication costs of the argument by using an $n$-ary base. This gives rise to the efficiencies listed in Table~\ref{taEfficiency9}.
\begin{description}
\item[ Polynomial Encoding: ] Let $N=n^m-1$. Let $a_0,\ldots,a_{m-1}$ be the $n$-ary representation of $a$, so that $\prod_{k=0}^{n-1} (a_i - k) = 0$ for $0 \leq i \leq m-1$. Then $a = \sum_{i=0}^{m-1} a_i n^i$.
\item[ Parameter Choice: ] \ 
\begin{itemize}
\item $\ell_a=m$, $\ell_b=m$, $\ell_P=m$, $d_P=n$, $\ell_Q=1$, $d_Q=1$ 
\item $\vec{a} = (a_0,\ldots,a_{m-1})$
\item $\vec{b} = (1,n,\ldots,n^{m-1})$
\item $P(\vec{a},\vec{b}) = \vec{a} \circ ( \vec{a}-\vec{1} ) \circ \ldots ( \vec{a} - n+1 ) $
\item $Q(\vec{a},\vec{b}) = \sum_{i=0}^{m-1} a_i n^i$
\end{itemize}
\end{description}

When $t=1$ and we are aiming for a constant number of commitments, setting $n=4$ gives the lowest communication costs. When $t=1$ and we aim to minimise the total number of elements communicated in the compiled proof, we set $n = \frac{\log_2N}{\log_2 \log_2 N}$. Otherwise, in the cases where $t$ is large, setting $n=6$ gives the lowest communication costs. The protocol efficiency is reported in Table~\ref{taEfficiency9}.

\section{3-Move Square-Root Protocol} \label{subsec:3rndsqrt}

In this section, we present an \ILC\ protocol for arithmetic circuit satisfiability which consists of only 3 moves. This yields, for example, using the later compilation with discrete logarithm comitments, the first known zero-knowledge argument of knowledge for arithmetic circuit satisfiability that has square-root communication complexity, and only 3 moves, based on the discrete logarithm assumption. The previous best arguments \cite{Seo2011a,Groth2009b} consisted of 5 moves.

One might ask why \red{Fill in!}

We will construct SHVZK proofs of knowledge for the relation $\Rac$, where the instances are arithmetic circuits over a field $\F$ specified by $\crs$. An instance consists of many fan-in 2 addition and multiplication gates over $\F$, a description of how wires in the circuit connect to the gates, and values assigned to some of the input wires. Witnesses $\wit$ are the remaining inputs such that the output of the circuit is $0$. For an exact definition of how we represent an arithmetic circuit, see Section \ref{sec:AC}.

\red{Poor writing, instead of doing this here, put this in the 5-round section and refer to the earlier argument}
In our later 5 round argument we check that committed vectors had the correct Hadamard product, and we check consistency equations between them. The idea behind this protocol is to do exactly the same thing, but in 3 rounds. An approach similar to that of \cite{PHGR13} works well for doing many operations in parallel, so this will be used for the Hadamard product. Embedding field elements as the coefficients of polynomials as in \cite{Groth2009b} works well for scalar products, so will be used for the consistency equations.

The Hadamard product component of this argument is not new. It is the Hadamard Product argument of section 5.4, \cite{Bayer2014}.

One disadvantage of this approach is that the prover sends the blinded wire values to the verifier more than once. Nevertheless, the compiled protocol achieves a square-root complexity in 3 rounds.

The relation corresponding to the proof is
\[
\R_{\textnormal{AC1}}=\left\{\begin{array}{c}
(\crs_{\ILC~},\stm,\wit); \ \crs_\ILC = (\F,n,Q,(z_1,\ldots,z_m)), \\
u = \left( \{\vec{w}_{q,{a,i}},\vec{w}_{q,{b,i}},\vec{w}_{q,{c,i}}\}_{q \in [Q], i \in [m]}, \{K_{q}\}_{q \in [Q]}\right), \\
\wit = \{\vec{a}_i,\vec{b}_i,\vec{c}_i\}_{i \in m}:\\
\forall q \in [Q], \forall i \in [m], \quad \vec{w}_{q,a,i}, \vec{w}_{q,b,i}, \vec{w}_{q,c,i} \in \F^n \\
\forall i \in [m], \quad \vec{a}_i,\vec{b}_i,\vec{c}_i \in \F^n, \quad \vec{a}_i \circ \vec{b}_i=\vec{c}_i \\
\wedge \quad \forall q \in [Q], \quad \sum_{q=1}^Q \vec{w}_{q,a,i} \cdot \vec{a}_i + \sum_{q=1}^Q \vec{w}_{q,b,i} \cdot \vec{b}_i + \sum_{q=1}^Q \vec{w}_{q,c,i} \cdot \vec{c}_i = K_q
\end{array}\right\}
\]

\subsection{Idea}

The prover will begin by commiting to each $\vec{a}_{i}$, $\vec{b}_i$ and $\vec{c}_i$ for each $i$.

Given distinct points $z_1,\ldots,z_m$, let $l_i(X)$ be the Lagrange polynomials, and $l_0(X)$ be defined as before. The Hadamard product holds if and only if there exists a polynomial $\vec{d}(X)$ of degree $m-2$ such that the following polynomial equation holds:
\begin{align*}
\left( \sum_{i=1}^m \vec{a}_i l_i(X) \right) \circ \left( \sum_{i=1}^m \vec{b}_i l_i(X) \right) - \left( \sum_{i=1}^m \vec{c}_{i} l_i(X) \right) = \vec{\DDelta}(X) l_0(X)
\end{align*}
 The prover can commit to the coefficients $\vec{\DDelta}_i$ of $\vec{\DDelta}(X)$ beforehand. Then, for a randomly chosen challenge $x$, the verifier can make the following \ILC\ queries.
\begin{align*}
\vec{\bar{a}} &= \sum_{i=1}^m \vec{a}_{i} l_i(x) && \vec{\bar{c}} = \sum_{i=1}^m \vec{c}_{i} l_i(x) + l_0(x) \sum_{i=0}^{m-2} \vec{\DDelta}_i x^i \\ \\
\vec{\bar{b}} &= \sum_{i=1}^m \vec{b}_{i} l_i(x) &
\end{align*}
with suitable random blinding values used in the real protocol to hide the wire values. The verifier can then verify that the Hadamard product holds by checking whether $\bar{\vec{a}} \circ \bar{\vec{b}} \vereq \bar{\vec{c}}$.

Define the following polynomials.
\begin{align*}
\vec{\bar{e}}(X) &= \sum_{i=1}^m \vec{a}_i X^i + X^m \sum_{i=1}^m \vec{b}_{i} X^i + X^{2m} \sum_{i=1}^m \vec{c}_{i} X^i \\ \\
\vec{w}_q(X) &= \sum_{i=1}^m \vec{w}_{q,a,i} X^{-i} + X^{-m} \sum_{i=1}^m \vec{w}_{q,b,i} X^{-i} + X^{-2m} \sum_{i=1}^m \vec{w}_{q,c,i} X^{-i}
\end{align*}
The linear consistency equations hold if and only if there exist vectors $\vec{h}_j \in \F^Q$ such that the following polynomial equation holds:
\[
( \vec{\bar{e}}(X) \cdot \vec{w}_1(X),\ldots, \vec{\bar{e}}(X)\cdot \vec{w}_Q(X) )  = (K_1,\ldots,K_Q) + \sum_{j\neq 0, j=-3m}^{3m} \vec{h}_j {X^j}
\]
The prover can commit to the vectors $\vec{h}_j$ in before receiving $x$. Then verifier can make \ILC \ queries to obtain $\vec{e}(X)$ and also
\[
\vec{h} = \sum_{j\neq 0, j=-3m}^{3m} \vec{h}_j {x^j}
\]
Since all of the coefficients are public, the verifier can compute $\vec{w}_q(x)$ by themselves for each $q \in [Q]$. Finally, the verifier can verify that the linear consistency equations hold by checking whether
\[
( \vec{\bar{e}}\cdot \vec{w}_1(x),\ldots, \vec{\bar{e}}\cdot \vec{w}_Q(x) ) \vereq (K_1,\ldots,K_Q) + \sum_{j\neq 0, j=-3m}^{3m} \vec{h}_j {x^j}
\]

This protocol was the main motivation for introducing the \ILCcheck\ command to the \ILC\ model. If this command had not been introduced, then the verifier might have made a \ILCopen\ query for $(K_1,\ldots,K_Q) + \sum_{j\neq 0, j=-3m}^{3m} \vec{h}_j {x^j}$. Following the compilation in \cite{BootleCGGHJ17}, this would have resulted in the prover sending a vector of length $Q$ to the verifier. In general, $Q$ could be as large as $N$, the number of multiplication gates in the arithmetic circuit. However, it is unnecessary for the prover to send this value to the verifier, as in a real proof, the verifier can compute $( \vec{\bar{e}}\cdot \vec{w}_1(x),\ldots, \vec{\bar{e}}\cdot \vec{w}_Q(x) )$ and check this value against succinct commitments to the $\vec{h}_j$.

\begin{description}\label{prot:3ac}
\item[Common input:] Setup information $\crs_\ILC = (\F,n,Q,(z_1,\ldots,z_m))$. The description of an arithmetic circuit $u = \left( \{\vec{w}_{q,{a,i}},\vec{w}_{q,{b,i}},\vec{w}_{q,{c,i}}\}_{q \in [Q], i \in [m]}, \{K_{q}\}_{q \in [Q]}\right)$.
\item[Prover's witness:] Satisfying assignments $\wit = \{\vec{a}_i,\vec{b}_i,\vec{c}_i\}_{i \in m}$ to the wires of the circuit.
\item[Protocol:]
\item[\ P:]

The prover randomly selects $\vec{a}_{0},\vec{b}_{0},\vec{c}_{0}\gets \F^n$, and sends them to the \ILC. For $i \in [m]$, the prover sends $\vec{a}_{i}$, $\vec{b}_{i}$ and $\vec{c}_{i} \in \F^n$ to the \ILC. The prover computes $\vec{\DDelta}_0,\ldots,\vec{\DDelta}_m \in \F^n$ such that
\[
\left( \sum_{i=0}^m \vec{a}_{i} l_i(X) \right) \circ \left( \sum_{i=0}^m \vec{b}_{i} l_i(X) \right) - \left( \sum_{i=0}^m \vec{c}_{i} l_i(X) \right) = l_0(X) \sum_{i=0}^m \vec{\DDelta}_i X^i
\]
Note that the sums on the left begin from $i=0$ to incorporate the blinders. For $0 \leq i \leq m$, the prover sends $\vec{\DDelta}_i$ to the \ILC.

The prover randomly selects $\vec{e} \gets \F^n$ and sends it to \ILC. The prover computes $\vec{h}_j \in \F^Q$ such that
\[
(\vec{\bar{e}}(X)\cdot \vec{w}_1(X),\ldots,\vec{\bar{e}}(X)\cdot \vec{w}_Q(X)) = (c_1,\ldots,c_Q) + \sum_{j\neq 0,j=-3m}^{3m} \vec{h}_{j} X^j
\]
where
\begin{align*}
\vec{\bar{e}}(X) &= \vec{e} + \sum_{i=1}^m \vec{a}_{i} X^i + X^m \sum_{i=1}^m \vec{b}_{i} X^i + X^{2m} \sum_{i=1}^m \vec{c}_{i} X^i \\
\vec{w}_q(X) &= \sum_{i=1}^m \vec{w}_{q,a,i} X^{-i} + X^{-m} \sum_{i=1}^m \vec{w}_{q,b,i} X^{-i} + X^{-2m} \sum_{i=1}^m \vec{w}_{q,c,i} X^{-i}
\end{align*}
For $j\neq 0,-3m \leq j \leq 3m$, the prover sends $\vec{h}_j$ to the \ILC.

\item[\ V:] The verifier randomly selects $x\gets \F^*$, and makes the following queries to \ILC.
\[
\bar{\vec{e}} = \vec{e} + \sum_{i=1}^m \vec{a}_{i} x^i + x^m \sum_{i=1}^m \vec{b}_{i} x^i + x^{2m} \sum_{i=1}^m \vec{c}_{i} x^i
\]
\begin{align*}
\bar{\vec{a}} = \sum_{i=0}^m \vec{a}_{i} l_i(x) && \bar{\vec{b}} = \sum_{i=0}^m \vec{b}_{i} l_i(x)
\end{align*}
For each $q \in [Q]$, the verifier computes
\[
\vec{w}_q = \sum_{i=1}^m \vec{w}_{q,a,i} x^{-i} + x^{-m} \sum_{i=1}^m \vec{w}_{q,b,i} x^{-i} + x^{-2m} \sum_{i=1}^m \vec{w}_{q,c,i} x^{-i}
\]
The verifier performs the following checks, using one \ILCcheck\ query for each.
\begin{align*}
\vec{\bar{a}} \circ \vec{\bar{b}} ~&\vereq~ \sum_{i=0}^m \vec{c}_{i} l_i(x) + l_0(x) \sum_{i=0}^m \vec{\DDelta} x^i \\ \\
\left(\vec{\bar{a}}\cdot \vec{w}_1,\ldots,\vec{\bar{a}}\cdot \vec{w}_Q \right) ~&\vereq~ (c_1,\ldots,c_Q) \quad + \sum_{j\neq 0,j=-3m}^{3m} \vec{h}_j {x^j}
\end{align*}
\end{description}

\begin{thm}
The argument of subsection \ref{prot:3ac} for satisfiability of an arithmetic circuit has perfect completeness, knowledge-soundness and special honest verifier zero-knowledge.
\end{thm}

\begin{proof} Perfect completeness follows by careful inspection.

For SHVZK, we describe a simulator. Given a challenge $x$ such that $l_0(x) \neq 0$, the simulator randomly selects $\vec{\bar{a}}$ and $\vec{\bar{b}}$ uniformly at random from $\F^n$ and $\bar{\vec{e}}$ uniformly at random from $\F^Q$. These are distributed exactly as in a real argument. Therefore the simulated argument is indistinguishable from a real argument and we have SHVZK.

Finally, we prove knowledge-soundness. The \ILC~ knowledge extractor already has access to all messages sent between the prover and \ILC. It remains to show that if the committed values are not a valid witness, then there is a negligible probability that the verifier will accept.
Recall that the verifier makes \ILCopen \ queries in order to obtain the following values.
\begin{align*}
\bar{\vec{a}} = \sum_{i=0}^m \vec{a}_{i} l_i(x) &&
\bar{\vec{b}} = \sum_{i=0}^m \vec{b}_{i} l_i(x)
\end{align*}
Now, substitute these expressions into the expression containing $\bar{\vec{a}}$ and $\bar{\vec{b}}$ that arises from the \ILCcheck\ query. This yields the following polynomial equation evaluated at $x$.
\begin{align}\label{eq:lagrangeprod}
\left( \sum_{i=0}^m \vec{a}_i l_i(x) \right) \circ \left( \sum_{i=0}^m \vec{b}_i l_i(x) \right) - \sum_{i=0}^m \vec{c}_{i} l_i(x) - \sum_{i=0}^m \vec{\DDelta}_i l_0(x) = 0
\end{align}
By assumption $\PoProdMal$ is deterministic, and we know when it made its commitments. Hence, all of the vector coefficients in Equation \ref{eq:lagrangeprod} are constant with respect to $x$. If there exist $i$ and $j$ such that $\vec{a}_{i,j}\circ \vec{b}_{i,j}\neq \vec{c}_{i,j}$, then Equation \ref{eq:lagrangeprod} is a non-zero polynomial of degree $2m$ which is zero at $x$. Since a polynomial of degree $2m$ can have at most $2m$ roots, the probability that this equality holds is at most $\frac{2m}{|\F| - m}$. The verifier can only accept if we have equality, so this shows that the probability that the committed values does not satisfy the product relation but verifier accepts is negligible, which proves knowledge soundness.\qed
\end{proof}

\begin{lemma}
The protocol has tree-special soundness, and the extraction algorithm $\chi$ is a linear map.
\end{lemma}

\begin{proof}
The verifier sees the following queries as part of the protocol.
\[
\bar{\vec{e}} = \vec{e} + \sum_{i=1}^m \vec{a}_{i} x^i + x^m \sum_{i=1}^m \vec{b}_{i} x^i + x^{2m} \sum_{i=1}^m \vec{c}_{i} x^i
\]
\begin{align*}
\bar{\vec{a}} = \sum_{i=0}^m \vec{a}_{i} l_i(x) && \bar{\vec{b}} = \sum_{i=0}^m \vec{b}_{i} l_i(x)
\end{align*}
\begin{align*}
\vec{\bar{a}} \circ \vec{\bar{b}} ~&\vereq~ \sum_{i=0}^m \vec{c}_{i} l_i(x) + l_0(x) \sum_{i=0}^m \vec{\DDelta} x^i \\ \\
\left(\vec{\bar{a}}\cdot \vec{w}_1,\ldots,\vec{\bar{a}}\cdot \vec{w}_Q \right) ~&\vereq~ (c_1,\ldots,c_Q) \quad + \sum_{j\neq 0,j=-3m}^{3m} \vec{h}_j {x^j}
\end{align*}
These all correspond to cases of Lemma \ref{lem:linextract}. Therefore, given the verifier's view for sufficiently many distinct values of $x$, one can recover the committed polynomial using a linear map. \qed
\end{proof}

\begin{lemma}
With high probability, the \ILC\ query matrix for the protocol has full rank, and fewer rows than columns.
\end{lemma}

\begin{proof}
The rows of the query matrix correspond to the number of \ILC\ queries made by the verifier. The columns correspond to vectors which the prover has committed to. In this protocol, there are a constant number of queries, including the queries from the polynomial commitment sub-protocol, so there are clearly fewer queries than commitments whenever $m$ is large enough. The query matrix has full rank. This is because the rows corresponding to each query operate on different commitments. Since each row operates on different commitments to the others, the entire query matrix has full rank. With high probability over the choice of $x$, all queries are non-trivial. \qed
\end{proof}

\subsection{Efficiency}

\paragraph{Communication}

The prover sends $4m+4$ vectors of length $n$ and $6m$ vectors of length $Q$ to \ILC. %and $4n+6$ field elements to the verifier.
Choosing $n \approx m \approx \sqrt{N}$ minimises the total cost in the compiled proof. %gives a total cost of $\approx 14 \sqrt{N} + 11$ group and field elements.

\paragraph{Computation}
%The prover can make all necessary commitments using roughly $\frac{4 \lambda mn}{\log n} + \frac{6\lambda Qm}{\log Q}$ group operations by making use of multi-exponentiation algorithms.
The dominant cost for the prover in field multiplications is $O(Qmn \log m)$ from multiplying vectors of polynomials using FFT techniques.
%The number of group operations required for the verifier is $O(\frac{m+n}{\log (m+n)} + \frac{Q+m}{\log (Q+m)})$.
For the verifier, the number of field multiplications is dominated by $3Qmn$.

%\section{Extension to 5-Move Amortised Prover Protocol} \label{subsec:5rndamort}
%
%We show how to extend the 3-move $\ILC~$ protocol for arithmetic circuit satisfiability to a 5-move protocol which has the additional property that it is easy to produce a large number of rerandomised proofs at the same time, for example, in the non-interactive setting, where the verifier's challenges are eventually computed using a hash function, and the prover is able to learn many of them at the same time. This could be advantageous in the situation where the prover wishes to produce many unlinkable proofs of the same statement, and give them to different parties.
%
%As with the previous proof, the relation corresponding to the proof is
%\[
%\R_{\textnormal{AC1}}=\left\{\begin{array}{c}
%(\crs_{\ILC~},\stm,\wit); \ \crs_\ILC = (\F,n,Q,(z_1,\ldots,z_m)), \\
%u = \left( \{\vec{w}_{q,{a,i}},\vec{w}_{q,{b,i}},\vec{w}_{q,{c,i}}\}_{q \in [Q], i \in [m]}, \{K_{q}\}_{q \in [Q]}\right), \\
%\wit = \{\vec{a}_i,\vec{b}_i,\vec{c}_i\}_{i \in m}:\\
%\forall q \in [Q], \forall i \in [m], \quad \vec{w}_{q,a,i}, \vec{w}_{q,b,i}, \vec{w}_{q,c,i} \in \F^n \\
%\forall i \in [m], \quad \vec{a}_i,\vec{b}_i,\vec{c}_i \in \F^n, \quad \vec{a}_i \circ \vec{b}_i=\vec{c}_i \\
%\wedge \quad \forall q \in [Q], \quad \sum_{q=1}^Q \vec{w}_{q,a,i} \cdot \vec{a}_i + \sum_{q=1}^Q \vec{w}_{q,b,i} \cdot \vec{b}_i + \sum_{q=1}^Q \vec{w}_{q,c,i} \cdot \vec{c}_i = K_q
%\end{array}\right\}
%\]
%
%\subsection{Idea}
%
%The previous protocol compresses many vectors into single vectors using Lagrange polynomials and monomials in a variable $X$. Imagine repeating the protocol several times. Let us consider which values change, and which values stay the same. All of the wire values in the protocol stay the same. The random values of the challenge $x$ also change from protocol run to protocol run. Finally, the random blinding values $\vec{a}_{0}$, $\vec{b}_{0}$ and $\vec{c}_{0}$ change from protocol run to protocol run. The verifier receives polynomial evaluations for different polynomials in every run.
%
%Now imagine running the protocol without any random blinding values. The coefficients $\vec{\DDelta}$ and $\vec{h}$ of the polynomials in $X$ computed by the prover would be the same in every run. Then, although $x$ would change with every run, given many values of $x$ at the same time, multi-point polynomial evaluation techniques would make it very easy to produce all of the polynomial evaluations at the same time with minimal overhead.
%
%However, without random blinding values, the proof would not be zero-knowledge. To solve this problem, note that the random challenge $x$ basically serves to compress all of the vectors of wire values into single vectors, one for checking multiplicative relations, and one for checking scalar products, and the verifier performs simple operations on these single vectors. We can then run a simple zero-knowledge sub-protocol on the compressed values, using uniformly random blinders with each new run. This leads to new computations in each run of the entire protocol, but the cost is low since the sub-protocols are only run on single compressed vectors, rather than a large number of vectors as in the old protocol.
%
%\begin{description}
%\item[Common input:] Setup information $\crs_\ILC = (\F,n,Q,(z_1,\ldots,z_m))$. The description of an arithmetic circuit $u = \left( \{\vec{w}_{q,{a,i}},\vec{w}_{q,{b,i}},\vec{w}_{q,{c,i}}\}_{q \in [Q], i \in [m]}, \{K_{q}\}_{q \in [Q]}\right)$.
%\item[Prover's witness:] Satisfying assignments $\wit = \{\vec{a}_i,\vec{b}_i,\vec{c}_i\}_{i \in m}$ to the wires of the circuit.
%\item[Protocol:]
%\item[\ P:]
%
%The prover randomly selects $\vec{a}_{0}$ and $\vec{b}_{0}\gets \F^n$, and sends them to the \ILC. For $i \in [m]$, the prover sends $\vec{a}_{i}$, $%\vec{b}_{i}$ and $\vec{c}_{i} \in \F^n$ to the \ILC. The prover computes $\vec{\DDelta}_0,\ldots,\vec{\DDelta}_m \in \F^n$ such that
%\[
%\left( \sum_{i=1}^m \vec{a}_{i} l_i(X) \right) \circ \left( \sum_{i=1}^m \vec{b}_{i} l_i(X) \right) - \left( \sum_{i=1}^m \vec{c}_{i} l_i(X) \right) = l_0(X) %\sum_{i=0}^{m-2} \vec{\DDelta}_i X^i
%\]
%For $0 \leq i \leq m$, the prover sends $\vec{\DDelta}_i$ to the \ILC.
%
%The prover randomly selects $\vec{e} \gets \F^n$ and sends it to \ILC. The prover computes $\vec{h}_j \in \F^Q$ such that
%\[
%(\vec{\bar{e}}(X)\cdot \vec{w}_1(X),\ldots,\vec{\bar{e}}(X)\cdot \vec{w}_Q(X)) = (K_1,\ldots,K_Q) + \sum_{j\neq 0,j=-3m}^{3m} \vec{h}_{j} X^j
%\]
%where%
%\begin{align*}
%\vec{\bar{e}}(X) &= \sum_{i=1}^m \vec{a}_{i} X^i + X^m \sum_{i=1}^m \vec{b}_{i} X^i + X^{2m} \sum_{i=1}^m \vec{c}_{i} X^i \\
%\vec{w}_q(X) &= \sum_{i=1}^m \vec{w}_{q,a,i} X^{-i} + X^{-m} \sum_{i=1}^m \vec{w}_{q,b,i} X^{-i} + X^{-2m} \sum_{i=1}^m \vec{w}_{q,c,i} X^{-i}
%\end{align*}
%For $j\neq 0,-3m \leq j \leq 3m$, the prover sends $\vec{h}_j$ to the \ILC.
%\item[\ V:] The verifier randomly selects $x\gets \F^*$ and sends it to \ILC~.
%\item[\ P:] After querying $x$ from \ILC~, the prover computes the following.
%\begin{align*}
%\bar{\vec{a}}(Z) = \vec{a}_{0} Z + \left(\sum_{i=1}^m \vec{a}_{i} l_i(x)\right) &&
%\bar{\vec{b}}(Z) = \vec{b}_{0} Z + \left(\sum_{i=1}^m \vec{b}_{i} l_i(x)\right)\\
%\bar{\vec{c}} = \quad + \left(\sum_{i=1}^m \vec{c}_{i} l_i(x)\right)
%\end{align*}
%\begin{align*}
%\bar{\vec{a}}(Z) \circ \bar{\vec{b}}(Z) - \bar{\vec{c}} &= (\vec{a}_{0} \circ \vec{b}_{0}) Z^2 + \vec{a}_{0} \circ \left(\sum_{i=1}^m \vec{b}_{i} l_i(x)%\right) Z + \vec{b}_{0} \circ \left(\sum_{i=1}^m \vec{a}_{i} l_i(x)\right) Z \\ \\
%&\quad + \left(\sum_{i=1}^m \vec{a}_{i} l_i(x)\right) \circ \left(\sum_{i=1}^m \vec{b}_{i} l_i(x)\right) - \left(\sum_{i=1}^m \vec{c}_{i} l_i(x)\right) \\ \\
%&= \vec{f}_2 Z^2 + \vec{f}_1 Z + l_0(x) \sum_{i=0}^{m-2} \vec{\DDelta}_i x^i
%\end{align*}
%The prover sends $\vec{f}_2$ and $\vec{f}_1$ to \ILC. The prover computes the following.
%\begin{align*}
%\bar{\vec{e}}(Z) &= \vec{e}Z + \left(\sum_{i=1}^m \vec{a}_{i} x^i + x^m \sum_{i=1}^m \vec{b}_{i} x^i + x^{2m} \sum_{i=1}^m \vec{c}_{i} x^i\right) \\ \\
%\vec{w}_q &= \sum_{i=1}^m \vec{w}_{q,a,i} x^{-i} + x^{-m} \sum_{i=1}^m \vec{w}_{q,b,i} x^{-i} + x^{-2m} \sum_{i=1}^m \vec{w}_{q,c,i} x^{-i}, q \in [Q] \\ \\
%(\bar{\vec{e}}(Z) \cdot \vec{w}_1,\ldots,&\bar{\vec{e}}(Z) \cdot \vec{w}_Q)
%= \vec{f}_3 Z + (K_1,\ldots,K_Q) + \sum_{j\neq 0,j=-3m}^{3m} \vec{h}_{j} x^j
%\end{align*}
%The prover sends $\vec{f}_3$ to \ILC~.
%\item[\ V:] The verifier randomly selects $z\gets \F$, and makes the following \ILCopen\ queries.
%\begin{align*}
%\vec{\bar{a}} = \vec{a}_{0}z + \sum_{i=1}^m \vec{a}_{i} {l_i(x)} &&
%\vec{\bar{b}} = \vec{b}_{0}z + \sum_{i=1}^m \vec{b}_{i} {l_i(x)}
%\end{align*}
%\[
%\vec{\bar{e}} = \vec{e}z + \sum_{i=1}^m \vec{a}_{i}^{x^i} + {x^m} \sum_{i=1}^m \vec{b}_{i}^{x^i} + {x^{2m}} \sum_{i=1}^m \vec{c}_{i}^{x^i}
%\]
%The verifier makes the following \ILCcheck\ queries.
%\begin{align*}
%\vec{\bar{a}} \circ \vec{\bar{b}} &\vereq \vec{f}_2 z^2 + \vec{f}_1 z + \sum_{i=1}^m \vec{c}_{i} {l_i(x)} + {l_0(x)} \sum_{i=0}^{m-2} \vec{\DDelta}_i^{x^i} \\
%\left(\vec{\bar{e}}\cdot \vec{w}_1,\ldots,\vec{\bar{e}}\cdot \vec{w}_Q \right) &= \vec{f}_3 z + (c_1,\ldots,c_Q) + \sum_{j\neq 0,j=-3m}^{3m} \vec{h}_j {x^j}
%\end{align*}
%\end{description}
%
%\begin{thm}
%The argument for satisfiability of an arithmetic circuit has perfect completeness, knowledge-soundness and special honest verifier zero-knowledge.
%\end{thm}
%
%\begin{proof} Perfect completeness follows by careful inspection.
%
%For SHVZK, we describe a simulator. Given a challenge $x$ such that $l_0(x) \neq 0$, the simulator randomly selects $\vec{\bar{a}}$ ,$\vec{\bar{b}}$ and $\vec{\bar{e}} \gets \F^n$. These are distributed exactly as in a real argument. Therefore the simulated argument is indistinguishable from a real argument and we have SHVZK.
%
%Finally, we prove knowledge-soundness. The \ILC~ knowledge extractor already has access to all messages sent between the prover and \ILC~. It remains to show that if the committed values are not a valid witness, then there is a negligible probability that the verifier will accept.
%Recall that verifier makes the following \ILCopen\ queries.
%\begin{align*}
%\vec{\bar{a}} = \vec{a}_{0}z + \sum_{i=1}^m \vec{a}_{i} {l_i(x)} &&
%\vec{\bar{b}} = \vec{b}_{0}z + \sum_{i=1}^m \vec{b}_{i} {l_i(x)}
%\end{align*}
%\[
%\vec{\bar{e}} = \vec{e}z + \sum_{i=1}^m \vec{a}_{i}^{x^i} + {x^m} \sum_{i=1}^m \vec{b}_{i}^{x^i} + {x^{2m}} \sum_{i=1}^m \vec{c}_{i}^{x^i}
%\]
%Now, substitute the expressions for $\bar{\vec{a}}$, $\bar{\vec{b}}$ and $\bar{\vec{e}}$ into the verifier's \ILCcheck\ queries.
%\begin{align*}
%\vec{\bar{a}} \circ \vec{\bar{b}} &\vereq \vec{f}_2 z^2 + \vec{f}_1 z + \sum_{i=1}^m \vec{c}_{i} {l_i(x)} + {l_0(x)} \sum_{i=0}^{m-2} \vec{\DDelta}_i^{x^i} \\ \\
%\left(\vec{\bar{e}}\cdot \vec{w}_1,\ldots,\vec{\bar{e}}\cdot \vec{w}_Q \right) &= \vec{f}_3 z + (c_1,\ldots,c_Q) + \sum_{j\neq 0,j=-3m}^{3m} \vec{h}_j {x^j}\\ \\
%\text{where } \vec{w}_q = \sum_{i=1}^m \vec{w}_{q,a,i} x^{-i} &+ x^{-m} \sum_{i=1}^m \vec{w}_{q,b,i} x^{-i} + x^{-2m} \sum_{i=1}^m \vec{w}_{q,c,i} x^{-i}, q \in [Q]
%\end{align*}
%The verifier only accepts if the equations hold. By assumption $\PoProdMal$ is deterministic, and we know when it made its commitments. When we substitute the \ILCopen\ queries into the \ILCcheck\ queries and multiply out all terms, we get two expressions to which we can apply Lemma~\ref{szvariant}. If there exist $i$ and $j$ such that $\vec{a}_{i,j}\circ \vec{b}_{i,j}\neq \vec{c}_{i,j}$, or one of the linear consistency equations does not hold, then that means we have event $\eventsz$. The verifier can only accept if we have equality, so this shows that the probability that the committed values does not satisfy the product relation or linear consistency equations but the verifier still accepts is negligible, which proves knowledge soundness.\qed
%\end{proof}
%
%\begin{lemma}
%The protocol has tree-special soundness, and the extraction algorithm $\chi$ is a linear map.
%\end{lemma}
%
%\begin{proof}
%The verifier sees the following queries as part of the protocol.
%\begin{align*}
%\vec{\bar{a}} = \vec{a}_{0}z + \sum_{i=1}^m \vec{a}_{i} {l_i(x)} &&
%\vec{\bar{b}} = \vec{b}_{0}z + \sum_{i=1}^m \vec{b}_{i} {l_i(x)}
%\end{align*}
%\[
%\vec{\bar{e}} = \vec{e}z + \sum_{i=1}^m \vec{a}_{i}^{x^i} + {x^m} \sum_{i=1}^m \vec{b}_{i}^{x^i} + {x^{2m}} \sum_{i=1}^m \vec{c}_{i}^{x^i}
%\]
%\begin{align*}
%\vec{\bar{a}} \circ \vec{\bar{b}} &\vereq \vec{f}_2 z^2 + \vec{f}_1 z + \sum_{i=1}^m \vec{c}_{i} {l_i(x)} + {l_0(x)} \sum_{i=0}^{m-2} \vec{\DDelta}_i^{x^i} \\
%\left(\vec{\bar{e}}\cdot \vec{w}_1,\ldots,\vec{\bar{e}}\cdot \vec{w}_Q \right) &= \vec{f}_3 z + (c_1,\ldots,c_Q) + \sum_{j\neq 0,j=-3m}^{3m} \vec{h}_j {x^j}
%\end{align*}
%After relabelling the variables, these all correspond to cases of Lemma \ref{lem:linextract}. Therefore, given the verifier's view for sufficiently many distinct values of $x$, one can recover the committed polynomial using a linear map. \qed
%\end{proof}
%
%\begin{lemma}
%With high probability, the \ILC\ query matrix for the protocol has full rank, and fewer rows than columns.
%\end{lemma}
%
%\begin{proof}
%The rows of the query matrix correspond to the number of \ILC queries made by the verifier. The columns correspond to vectors which the prover has committed to. In this protocol, there are a constant number of queries, including the queries from the polynomial commitment sub-protocol, so there are clearly fewer queries than commitments whenever $m$ is large enough. The query matrix has full rank. This is because the rows corresponding to each query operate on different commitments. Since each row operates on different commitments to the others, the entire query matrix has full rank. With high probability over the choices of $x$ and $z$, all queries are non-trivial. \qed
%\end{proof}
%
%\subsection{Efficiency}
%
%\paragraph{Communication}
%
%The prover sends $10m+5$ vectors to \ILC~. Choosing $n \approx m \approx \sqrt{N}$ will give an optimal communication cost in the compiled protocol. %a total cost of $\approx 14 \sqrt{N} + 11$ group and field elements.
%
%\paragraph{Computation}
%The prover can make all necessary commitments using roughly $\frac{4 \lambda mn}{\log n} + \frac{6\lambda Qm}{\log Q}$ group operations by making use of multi-exponentiation algorithms.
%For the prover, the dominant cost in field multiplications is $O(Qmn \log m)$ from multiplying vectors of polynomials using FFT techniques.
%
%The number of group operations required for the verifier is $O(\frac{m+n}{\log (m+n)} + \frac{Q+m}{\log (Q+m)})$.
%For the verifier, the number of field multiplications is dominated by $3Qmn$.

\section{5-Move Square-Root Protocol} \label{subsec:5rndsqrt}

The basis for the protocol in this section was originally published in joint work \cite{BootleCCGP16} with Andrea Cerulli, Pyrros Chaidos, Jens Groth and Christophe Petit, as a discrete-logarithm based protocol.

We present and \ILC\ protocol for arithmetic circuit satisfiability which consists of 5 moves. This protocol is the similar to the protocol in \cite{BootleG18}, but is rewritten slightly as an \ILC\ protocol.

The relation corresponding to the proof is
\[
\R_{\textnormal{AC2}}=\left\{\begin{array}{c}
(\crs_{\ILC~},\stm,\wit); \ \crs_\ILC = (\F,n), \\
u = \left( \{\vec{w}_{q,{a,i}},\vec{w}_{q,{b,i}},\vec{w}_{q,{c,i}}\}_{q \in [Q], i \in [m]}, \{K_{q}\}_{q \in [Q]}\right), \\
\wit = \{\vec{a}_i,\vec{b}_i,\vec{c}_i\}_{i \in m}:\\
\forall q \in [Q], \forall i \in [m], \quad \vec{w}_{q,a,i}, \vec{w}_{q,b,i}, \vec{w}_{q,c,i} \in \F^n \\
\forall i \in [m], \quad \vec{a}_i,\vec{b}_i,\vec{c}_i \in \F^n, \quad \vec{a}_i \circ \vec{b}_i=\vec{c}_i \\
\wedge \quad \forall q \in [Q], \quad \sum_{q=1}^Q \vec{w}_{q,a,i} \cdot \vec{a}_i + \sum_{q=1}^Q \vec{w}_{q,b,i} \cdot \vec{b}_i + \sum_{q=1}^Q \vec{w}_{q,c,i} \cdot \vec{c}_i = K_q
\end{array}\right\}
\]
This relation has been modified slightly in comparison with the previous relation $\R_\text{AC1}$ used for the previous two arithmetic circuit protocols. The only changes are in the setup information. The previous protocols used Lagrange polynomials, so interpolation points $(z_1,\ldots,z_m)$ were included in the setup material. The previous protocols also required the prover to commit to vectors of lengths $n$ and $Q$, whereas this protocol only requires commitments to vectors of length $n$.

\paragraph{Motivation} Although \ref{subsec:3rndsqrt} already presents a protocol for arithmetic circuit satisfiability, it does not seem to admit further optimisation techniques or improvements. The protocol in this section reduces checking arithmetic circuit satisfiability to a scalar product check on committed values. If one considers the scalar-product argument of Chapter \ref{chapterlabel:Special-Optimisations} as a special opening protocol for scalar products on Pedersen commitments, one can combine the two protocols to produce a protocol for arithmetic circuit satisfiability with logarithmic communication complexity, as in \cite{BootleCCGP16}, and later in \cite{BunzBBPWM18}.

\paragraph{Overview} The argument works by folding both the Hadamard matrix product and the linear constraints of Section \ref{sec:AC} into a single polynomial equation, where a Laurent polynomial has 0 as its constant term, and use an \ILC~ protocol to prove that this is the case. We can optionally integrate the inner product argument of Section~\ref{se:innerproduct} into the compiled proof to reduce communication. 
%Next, we reduce this to a specific polynomial evaluating to 0. Next, we reduce the Hadamard product equation and the linear constraints to the Laurent polynomial evaluation problem considered in Section~\ref{sec:polcom}. Finally, we reduce the polynomial evaluation to an inner product relation. We then provide a formal description of our argument and analyse its security and efficiency.


Our technique improves on the efficiency of arguments such as \cite{Groth2009b} by making two main changes, each resulting in efficiency improvements.
\begin{itemize}
\item We do not need commitments to the input and output wires of addition gates. We handle addition gates with linear consistency equations thus yielding a significant performance improvement proportional to the number of addition gates. This parallels \cite{Gennaro2013} who also manage to eliminate addition gates when constructing Quadratic Arithmetic Programs from circuits.
\item We avoid black-box reductions to zero-knowledge arguments for generic linear algebra statements and instead design an argument directly for arithmetic circuit satisfiability. As a result, our square-root argument has only 5 moves, while the argument from~\cite{Groth2009b} requires 7 moves. We note that~\cite{Seo2011a} reduced the complexity of~\cite{Groth2009b} to 5 moves as well, but at a significant computational overhead whereas we also reduce the computational cost.
\end{itemize}

These improvements give us a square root communication complexity with respect to the number of multiplication gates in the circuit. This is because for a circuit with $N=mn$ multiplication gates, the prover makes $3m$ commitments to wire values in his first move, and later provides an opening consisting of $n$ field elements to a homomorphic combination of these commitments. Optimising the parameters by choosing $m\approx n \approx \sqrt{N}$
leads to square root complexity.
%In our square root complexity argument, the verifier uses $n$ field elements to check an inner product relation. Our key idea to reduce communication further is to use our inner product evaluation argument instead of sending these field elements. This  allows for verification of the inner product, and also provides an argument of knowledge of the opening of the commitment. We no longer need to open a large commitment, leading to a drastic reduction in communication complexity depending on the settings for the inner product argument.

Below we give a first informal exposition of our arguments, and follow with a formal description. 

\subsection{Idea}

Let us consider the relation which encodes arithmetic circuit satisfiability.
\[
\R_{\textnormal{AC2}}=\left\{\begin{array}{c}
(\crs_{\ILC~},\stm,\wit); \ \crs_\ILC = (\F,n), \\
u = \left( \{\vec{w}_{q,{a,i}},\vec{w}_{q,{b,i}},\vec{w}_{q,{c,i}}\}_{q \in [Q], i \in [m]}, \{K_{q}\}_{q \in [Q]}\right), \\
\wit = \{\vec{a}_i,\vec{b}_i,\vec{c}_i\}_{i \in m}:\\
\forall q \in [Q], \forall i \in [m], \quad \vec{w}_{q,a,i}, \vec{w}_{q,b,i}, \vec{w}_{q,c,i} \in \F^n \\
\forall i \in [m], \quad \vec{a}_i,\vec{b}_i,\vec{c}_i \in \F^n, \quad \vec{a}_i \circ \vec{b}_i=\vec{c}_i \\
\wedge \quad \forall q \in [Q], \quad \sum_{q=1}^Q \vec{w}_{q,a,i} \cdot \vec{a}_i + \sum_{q=1}^Q \vec{w}_{q,b,i} \cdot \vec{b}_i + \sum_{q=1}^Q \vec{w}_{q,c,i} \cdot \vec{c}_i = K_q
\end{array}\right\}
\]
This contains $N = mn$ multiplication constraints, and $Q$ linear consistency constraints.

Let $Y$ be a formal indeterminate. We will reduce the $N+Q$ equations above to a single polynomial equation in $Y$ by embedding each equation into a distinct power of $Y$. In our argument we will then require the prover to prove that this single equation holds when replacing $Y$ by a random challenge received from the verifier.

Let $\vec{Y}'$ denote the vector $(Y^m,\ldots,Y^{mn})$ and $\vec{Y}$ denote $(Y,Y^2,\ldots,Y^{m})$. Then, we can multiply~\eqref{eq1:product} by $\vec{Y}$ from the left and $\vec{Y}'^T$ on the right to obtain
$ \vec{Y} (A \circ B) \vec{Y'}^T = \vec{Y} C \vec{Y'}^T,$ or equivalently 
%$$ 
$$\sum_{i=1}^m   Y^i (\vec{a}_i \circ \vec{b}_i ) \cdot \vec{Y}'= \sum_{i=1}^m  Y^i (\vec{c}_i \cdot  \vec{Y}')$$
Since $(\vec{a} \circ \vec{b})  \cdot \vec{Y}' = \vec{a} \cdot  (\vec{b} \circ \vec{Y}')$, we obtain the following expression
$$ \sum_{i=1}^m  \vec{a}_i  \cdot ( \vec{b}_i \circ \vec{Y}') Y^i = \left( \sum_{i=1}^m \vec{c}_i Y^i \cdot \vec{Y}' \right)$$

This is easily seen to be equivalent to~\eqref{eq1:product}, because $(\vec{a}_{i})_j (\vec{b}_{i})_j = (\vec{c}_{i})_j$ appears in the coefficients of $Y^{i+jm}$, and $i+jm$ takes every value from $m+1$ to $M = N+m$ exactly once.
%

Moreover, the $Q$ linear constraints on the wires are satisfied if and only if $$\sum_{q=1}^Q \left(\sum_{i=1}^m \vec{a}_{i} \cdot \vec{w}_{q,{a,i}} +\sum_{i=1}^m \vec{b}_{i} \cdot  \vec{w}_{q,{b,i}} +\sum_{i=1}^m \vec{c}_{i}  \cdot \vec{w}_{q,{c,i}} \right)Y^q=\sum_{q=1}^Q K_{q}Y^q$$
since the $q$th constraint arises from comparing the coefficients of $Y^q$.
%
Combining the two polynomial equations by adding them after multiplying the latter by $Y^M$, and swapping summations, we see that the circuit is satisfied if and only if 
\begin{align*}\left( \sum_{i=1}^m  \vec{a}_i  \cdot ( \vec{b}_i \circ \vec{Y}') Y^i \right)+ \sum_{i=1}^m \vec{a}_{i}  \cdot \left( \sum_{q=1}^Q \vec{w}_{q,{a,i}}Y^{M+q}\right) +\sum_{i=1}^m \vec{b}_{i} \cdot  \left( \sum_{q=1}^Q \vec{w}_{q,{b,i}}Y^{M+q}\right)\\ +\sum_{i=1}^m \vec{c}_{i} \cdot  \left(- Y^i \vec{Y}' +  \sum_{q=1}^Q \vec{w}_{q,{c,i}}Y^{M+q}\right)
\qquad= \qquad\left(\sum_{q=1}^Q K_{q}Y^{M+q}\right)
\end{align*}

%
Let us define \begin{align*}
\vec{w}_{a,i}(Y)&=\sum_{q=1}^Q\vec{w}_{q,a,i}Y^{M+q} \qquad& \vec{w}_{b,i}(Y)&=\sum_{q=1}^Q\vec{w}_{q,b,i}Y^{M+q} \\
\vec{w}_{c,i}(Y)&=- Y^i \vec{Y}' +  \sum_{q=1}^Q \vec{w}_{q,c,i}Y^{M+q} \qquad& K(Y)&=\sum_{q=1}^Q K_q Y^{M+q}
\end{align*} 
Then the circuit is satisfied if and only if
%
%fix next equation
%
\begin{equation}~\label{eq4:poly} 
\sum_{i=1}^m  \vec{a}_i  \cdot (\vec{b}_i \circ \vec{Y}') Y^i + \sum_{i=1}^m \vec{a}_i  \cdot \vec{w}_{a,i}(Y)  +\sum_{i=1}^m \vec{b}_i \cdot \vec{w}_{b,i}(Y)   +\sum_{i=1}^m \vec{c}_i \cdot \vec{w}_{c,i}(Y) - K(Y) = 0 
\end{equation}

In the argument, the prover will commit to $\vec{a}_{i},\vec{b}_{i}$ and $\vec{c}_{i}$. The verifier will then issue a random challenge $y\gets \F^*$ and the prover will convince the verifier that the committed values satisfy Eq.~\ref{eq4:poly}, evaluated on $y$. If the committed values do not satisfy the polynomial equation,  the probability the equality holds for a random $y$ is negligible, so the prover is unlikely to be able to convince the verifier.

In order to show that~\eqref{eq4:poly} is satisfied, we craft a special Laurent polynomial $t(X)$ in a second formal indeterminate $X$, whose constant coefficient is exactly twice the left-hand side of~\eqref{eq4:poly}. Therefore, this polynomial will have zero constant term if and only if~\eqref{eq4:poly} is satisfied.
%
We define
\begin{align*}
\vec{r}(X)&:=\sum_{i=1}^m\vec{a}_{i}y^i X^{i}+\sum_{i=1}^m\vec{b}_{i} X^{-i}+X^m \sum_{i=1}^m\vec{c}_{i} X^{i}+\vec{d}X^{2m+1}\\
\vec{s}(X)&:=\sum_{i=1}^m\vec{w}_{a,i}(y)y^{-i} X^{-i}+\sum_{i=1}^m\vec{w}_{b,i}(y)X^{i}+ X^{-m} \sum_{i=1}^m\vec{w}_{c,i} (y) X^{-i}\\
\vec{r}'(X) &:= \vec{r}(X) \circ \vec{y}' + 2\vec{s}(X)\\
t(X)&:=\vec{r}(X)\cdot \vec{r}'(X)-2K(y)
\end{align*}
Here $\vec{y}'$ is the vector $\vec{Y}'$ evaluated at $y$, and $\vec{d}$ is a blinding vector consisting of random scalars that the prover commits to in the first round.
%
In the protocol, the prover will reveal $\vec{r}(x)$ for a randomly chosen challenge $x\in \F^*$, and the blinding vector $\vec{d}$ ensures that we can reveal $\vec{r}(x)$ without leaking information about $\vec{a}_{i},\vec{b}_i$ and $\vec{c}_i$.
%
We also observe that $\vec{s}(x)$ is efficiently computable from public information about the circuit and the challenges.

We have designed these polynomials such that the constant term of $\vec{r} \cdot ( \vec{r} \circ \vec{y}')$ is equal to $2 \sum_{i=1}^m  \vec{a}_i  \cdot (\vec{b}_i \circ \vec{y}') y^i$ and the constant term of $\vec{r} \cdot \vec{s}$ is equal to $ \sum_{i=1}^m \vec{a}_i  \cdot \vec{w}_{a,i}(y)  +\sum_{i=1}^m \vec{b}_i \cdot \vec{w}_{b,i}(y)   +\sum_{i=1}^m \vec{c}_i \cdot \vec{w}_{c,i}(y) $.
%
We conclude that the constant term of $t(X)$ is exactly twice the left-hand side of~\eqref{eq4:poly}, and is therefore zero if and only if the circuit is satisfied.

We are now in a position to describe a protocol with square root communication complexity. %In the argument, the prover commits to $t(X)$ in a similar way to the polynomial commitment algorithm of Section~\ref{sec:polcom}. 
%

The prover first commits to vectors $\vec{a}_{i},\vec{b}_i,\vec{c}_i$ and $\vec{d}$ and the verifier replies with a challenge $y\gets \F^*$. The prover  computes $t(X)$ and commits to it by committing to each coefficient using the \ILC\ functionality.
Then, the verifier selects a random challenge $x\gets \F^*$ and uses \ILC\ queries to get $\vec{r}(x)$ and an evaluation $v = t(x)$. 

The verifier computes $\vec{s}(x), \vec{r}'(x) $ and $K$, then checks if $v = \vec{r}(x) \cdot \vec{r}'(x)-2K$.
%
The verifier accepts the argument if both checks are satisfied.
%As described so far, the argument requires communicating $O(m)$ group elements and $O(n)$ field elements, so setting $m \approx n$ leads to square root communication. The argument improves on~\cite{Groth2009,Seo2011} by requiring only 5 moves without computational overhead and significantly reduces the computational complexity. However, breaking this ostensible square root communication barrier requires new ideas that we describe later.

\subsection{Protocol Description}\label{prot:5ac}

\begin{description}
\item[Common input:] Setup information $\crs_\ILC = (\F,n)$. The description of an arithmetic circuit $u = \left( \{\vec{w}_{q,{a,i}},\vec{w}_{q,{b,i}},\vec{w}_{q,{c,i}}\}_{q \in [Q], i \in [m]}, \{K_{q}\}_{q \in [Q]}\right)$.
\item[Prover's witness:] Satisfying assignments $\wit = \{\vec{a}_i,\vec{b}_i,\vec{c}_i\}_{i \in m}$ to the wires of the circuit.
\item[Protocol:]
\item[\ P:]
Choose $\vec{d} \gets \F^n$ uniformly at random, and send to \ILC. For $i \in [m]$, send $\vec{a}_{i},\vec{b}_{i},\vec{c}_{i}$ to \ILC.

\item[\ V:] The verifier randomly selects $y\gets \F^*$ and sends it to \ILC.

As argued before, the circuit determines vectors of polynomials $\vec{w}_{a,i}(Y)$, $\vec{w}_{b,i}(Y)$, $\vec{w}_{c,i}(Y)$ and $K(Y)$ such that $C$ is satisfiable if and only if 
$$
\sum_{i=1}^m  \vec{a}_i  \cdot (\vec{b}_i^T \circ \vec{Y}') Y^i+\sum_{i=1}^m \vec{a}_i  \cdot \vec{w}_{a,i}(Y)
+
\sum_{i=1}^m \vec{b}_i \cdot \vec{w}_{b,i}(Y)   +\sum_{i=1}^m \vec{c}_i \cdot \vec{w}_{c,i}(Y) =  K(Y)
$$
where $\vec{Y}'=(Y^m,\ldots,Y^{mn})$. Given $y$, both the prover and verifier can compute $K=K(y)$, $\vec{w}_{a,i}=\vec{w}_{a,i}(y)$, $\vec{w}_{b,i}=\vec{w}_{b,i}(y)$ and $\vec{w}_{c,i}=\vec{w}_{c,i}(y)$. The prover can obtain $y$ from \ILC.

\item[\ P:] The prover computes Laurent polynomials $\vec{r},\vec{s},\vec{r}'$, which have vector coefficients, and Laurent polynomial $t$, in the indeterminate $X$.
\begin{align*}
\vec{r}(X)&=\sum_{i=1}^m\vec{a}_{i}y^i X^{i}+\sum_{i=1}^m\vec{b}_{i} X^{-i}+X^m \sum_{i=1}^m\vec{c}_{i} X^{i}+\vec{d}X^{2m+1}\\
\vec{s}(X)&=\sum_{i=1}^m\vec{w}_{a,i}y^{-i} X^{-i}+\sum_{i=1}^m\vec{w}_{b,i}X^{i}+ X^{-m} \sum_{i=1}^m\vec{w}_{c,i}X^{-i}\\
\vec{r}'(X)&= \vec{r}(X) \circ \vec{y}' + 2\vec{s}(X)\\
 t(X)&=\vec{r}(X)\cdot \vec{r}'(X)-2K=\sum_{k=-3m,k \neq 0}^{4m+2}t_kX^{k}
\end{align*}
When the wires $\vec{a}_{i},\vec{b}_i,\vec{c}_i$ correspond to a satisfying assignment, the Laurent polynomial $t(X)$ will have constant term $t_0=0$. 

The prover commits to $t(X)$ by sending each coefficient $t_k$ to the \ILC.

\item[\ V:] The verifier randomly selects $x\gets \F^*$ and makes an \ILCopen\ queries to obtain
\begin{align*}
\vec{r} &= \sum_{i=1}^m\vec{a}_{i}x^{i} y^i+\sum_{i=1}^m\vec{b}_{i} x^{-i}+x^m \sum_{i=1}^m\vec{c}_{i} x^{i}+\vec{d}x^{2m+1}\\ \\
v &= \sum_{k=-3m,k \neq 0}^{4m+2}t_k x^{k}
\end{align*}
The verifier computes $\vec{r}'=\vec{r}\circ \vec{y}' +2\vec{s}(x)$. The verifier accepts only if the following check is satisfied.
$$\vec{r}\cdot \vec{r}'-2K \vereq v$$
\end{description}

\subsection{Security Analysis.}
\begin{thm}\label{th:mainAC}
The argument of subsection \ref{prot:5ac} for satisfiability of an arithmetic circuit has perfect completeness, perfect special honest verifier zero-knowledge and statistical witness-extended emulation for extracting either a breach of the binding property of the commitment scheme or a witness for the satisfiability of the circuit.
\end{thm}

\begin{proof}\label{ap:proofAC}
Perfect completeness follows by inspection and using the fact that the polynomial commitment protocol  and inner product argument also have perfect completeness.

For perfect special honest verifier zero-knowledge we are given $y,x\in \F^*$, which allows us to compute $\vec{w}_{a,i},\vec{w}_{b,i},\vec{w}_{c,i}$ and $K$ from the circuit. The simulator picks $\vec{r}\gets \F^n$. To see that the simulated components have the same distribution as a real argument observe $\vec{r}$ is uniformly random.

It remains to show that we have knowledge soundness. The \ILC\ knowledge extractor already has access to all messages sent between the prover and \ILC. It remains to show that if the committed values are not a valid witness, then there is a negligible probability that the verifier will accept.
Recall that the verifier makes an \ILCopen\ query in order to obtain the following value
\[
\vec{r} =\sum_{i=1}^m\vec{a}_{i}x^{i} y^i+\sum_{i=1}^m\vec{b}_{i} x^{-i}+x^m \sum_{i=1}^m\vec{c}_{i} x^{i}+\vec{d}x^{2m+1}\\
\]
then computes $\vec{r}'=\vec{r}\circ \vec{y}' +2\vec{s}(x)$. Substitute these values into the verifier's \ILCcheck\ query $\vec{r}\cdot \vec{r}'-2K \vereq \sum_{k=-3m,k \neq 0}^{4m+2}t_k x^{k}$.
Following the explanation before the description of the protocol, we obtain a polynomial equation in $x$ and $y$ of the following form:
\begin{align*}
\left(2 \sum_{i=1}^m  \vec{a}_i  \cdot (\vec{b}_i \circ \vec{y}') y^i + \sum_{i=1}^m \vec{a}_i  \cdot \vec{w}_{a,i}(y)  +\sum_{i=1}^m \vec{b}_i \cdot \vec{w}_{b,i}(y)   +\sum_{i=1}^m \vec{c}_i \cdot \vec{w}_{c,i}(y)\right) \\
+ \sum_{k=-3m,k \neq 0}^{4m+2}t'_k x^{k} = 0
\end{align*}
The verifier only accepts if the equation holds. By assumption $\PoProdMal$ is deterministic, and we know when it made it's commitments. Hence, all of the terms in $\vec{a}_i$, $\vec{b}_i$ and $\vec{c}_i$ are constants, and the $t'_k$ terms are functions of $y$. We can now apply Lemma~\ref{lem:szvariant}. If the circuit is not satisfied, then the coefficient of some power of $y$ in the equation above will be non-zero, which means that we have $\eventsz$. The verifier can only accept if we have equality, so this shows that the probability that the committed values do not satisfy the circuit but that the verifier still accepts is negligible, which proves knowledge soundness.\qed
\end{proof}

\begin{lemma}
The protocol has tree-special soundness, and the extraction algorithm $\chi$ is a linear map.
\end{lemma}

\begin{proof}
The verifier sees the following queries as part of the protocol.
\[
\vec{r} =\sum_{i=1}^m\vec{a}_{i}x^{i} y^i+\sum_{i=1}^m\vec{b}_{i} x^{-i}+x^m \sum_{i=1}^m\vec{c}_{i} x^{i}+\vec{d}x^{2m+1}\\
\]
$$\vec{r}\cdot \vec{r}'-2K \vereq \sum_{k=-3m,k \neq 0}^{4m+2}t_k x^{k}$$
After relabelling the variables, these all correspond to cases of Lemma \ref{lem:linextract}. Therefore, given the verifier's view for sufficiently many distinct values of $x$ and $y$, one can recover the committed polynomial using a linear map. \qed
\end{proof}

\begin{lemma}
With high probability, the \ILC\ query matrix for the protocol has full rank, and fewer rows than columns.
\end{lemma}

\begin{proof}
The rows of the query matrix correspond to the number of \ILC\ queries made by the verifier. The columns correspond to vectors which the prover has committed to. In this protocol, there are a constant number of queries, including the queries from the polynomial commitment sub-protocol, so there are clearly fewer queries than commitments whenever $m$ is large enough. The query matrix has full rank. This is because the rows corresponding to each query operate on different commitments. Since each row operates on different commitments to the others, the entire query matrix has full rank. With high probability over the choices of $x$ and $z$, all queries are non-trivial. \qed
\end{proof}

\subsection{Efficiency}

\paragraph{Communication} The argument above has the prover send $O(m)$ elements to \ILC. Setting $m \approx \sqrt{N}$, $n\approx \sqrt{N}$ will minimise the communication complexity in the compiled proof.%we get a total communication complexity where the total number of group and field elements sent is as low as possible and approximately $2\sqrt{N}$ each.
%
\paragraph{Computation} The main computational cost for the prover is computing $t(X)$ using FFT-based techniques, which costs $O( mn\log{m})$ multiplications in $\F$.
The main cost in the verification is computing $\vec{s}(X)$ given the description of the circuit which requires in the worst case $Qn$ multiplications in $\F$, considering arbitrary fan-in addition gates. In case of $O(N)$-size circuits with fan-in 2 gates, computing  $\vec{s}(X)$ requires $O(N)$ multiplications. Evaluating $\vec{s}(x)$ requires $3N$ multiplications.